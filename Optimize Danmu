/**
 * ä¼˜åŒ–ç‰ˆå¼¹å¹•è„šæœ¬
 * é‡‡ç”¨é«˜æ•ˆçš„ä¸¤æ­¥è¯·æ±‚ç­–ç•¥ï¼š
 * 1. é¦–æ¬¡æœç´¢è·å–animeIdå¹¶ç¼“å­˜
 * 2. æ ¹æ®animeId+é›†æ•°ç›´æ¥æ‹¼æ¥epidè¯·æ±‚å¼¹å¹•
 * 3. åŒç•ªå‰§åç»­é›†æ•°åªéœ€1æ¬¡commentè¯·æ±‚
 */

WidgetMetadata = {
  id: "danmu.optimized",
  title: "Optimize Danmu",
  version: "2.0.0",
  requiredVersion: "0.0.2",
  description: "é«˜æ•ˆè·å–å¼¹å¹•æ•°æ®ï¼Œæ”¯æŒæ™ºèƒ½epidæ¨ç†",
  author: "ğŸ Discount Codeï¼šVEUS",
  site: "",
  globalParams: [
    {
      name: "server",
      title: "è‡ªå®šä¹‰æœåŠ¡å™¨",
      type: "input",
      placeholders: [
        {
          title: "å¼¹å¼¹play",
          value: "https://api.dandanplay.net",
        },
      ],
    },
  ],
  modules: [
    {
      id: "searchDanmu",
      title: "æœç´¢å¼¹å¹•",
      functionName: "searchDanmu",
      type: "danmu",
      params: [],
    },
    {
      id: "getComments",
      title: "è·å–å¼¹å¹•",
      functionName: "getCommentsById",
      type: "danmu",
      params: [],
    },
  ],
};

// å†…å­˜ç¼“å­˜ï¼Œå­˜å‚¨å·²æœç´¢çš„ç•ªå‰§ä¿¡æ¯
const animeCache = new Map();

async function searchDanmu(params) {
  const { tmdbId, type, title, season, episode, link, videoUrl, server } = params;

  // ç”Ÿæˆç¼“å­˜key
  const cacheKey = `${title}_${type}_${season || ''}`;
  
  // æ£€æŸ¥ç¼“å­˜
  if (animeCache.has(cacheKey)) {
    const cachedAnime = animeCache.get(cacheKey);
    console.log(`ä»ç¼“å­˜è·å–: ${title}`);
    return {
      animes: [cachedAnime],
      fromCache: true
    };
  }

  let queryTitle = title;

  try {
    // è°ƒç”¨å¼¹å¼¹playæœç´¢API
    const response = await Widget.http.get(
      `${server}/api/v2/search/anime?keyword=${encodeURIComponent(queryTitle)}`,
      {
        headers: {
          "Content-Type": "application/json",
          "User-Agent": "ForwardWidgets/2.0.0",
        },
      }
    );

    if (!response) {
      throw new Error("è·å–æ•°æ®å¤±è´¥");
    }

    const data = response.data;

    // æ£€æŸ¥APIè¿”å›çŠ¶æ€
    if (!data.success) {
      throw new Error(data.errorMessage || "APIè°ƒç”¨å¤±è´¥");
    }

    // è¿‡æ»¤å¹¶åŒ¹é…ç•ªå‰§
    let animes = [];
    if (data.animes && data.animes.length > 0) {
      animes = data.animes.filter((anime) => {
        // ç±»å‹åŒ¹é…
        if (type === "tv" && (anime.type === "tvseries" || anime.type === "web")) {
          return true;
        } else if (type === "movie" && anime.type === "movie") {
          return true;
        }
        return false;
      });

      // å­£æ•°åŒ¹é…ï¼ˆå¦‚æœæœ‰å­£æ•°ä¿¡æ¯ï¼‰
      if (season && animes.length > 0) {
        const matchedAnimes = animes.filter((anime) => {
          return matchAnimeSeason(anime.animeTitle, title, season);
        });
        
        if (matchedAnimes.length > 0) {
          animes = matchedAnimes;
        }
      }

      // ç¼“å­˜ç¬¬ä¸€ä¸ªåŒ¹é…çš„ç»“æœ
      if (animes.length > 0) {
        animeCache.set(cacheKey, animes[0]);
      }
    }

    return {
      animes: animes,
      fromCache: false
    };
  } catch (error) {
    console.error("æœç´¢å¼¹å¹•å¤±è´¥:", error);
    throw error;
  }
}

async function getCommentsById(params) {
  const { server, commentId, animeId, link, videoUrl, season, episode, tmdbId, type, title } = params;

  // å¦‚æœå·²æœ‰commentIdï¼Œç›´æ¥è¯·æ±‚
  if (commentId) {
    return await fetchDanmuComments(server, commentId);
  }

  // å¦‚æœæœ‰animeIdï¼Œæ ¹æ®é›†æ•°æ¨ç†epid
  if (animeId && episode) {
    const inferredCommentId = inferEpisodeId(animeId, season, episode);
    if (inferredCommentId) {
      try {
        return await fetchDanmuComments(server, inferredCommentId);
      } catch (error) {
        console.warn(`æ¨ç†çš„commentId ${inferredCommentId} è¯·æ±‚å¤±è´¥ï¼Œå°è¯•å…¶ä»–æ–¹æ³•`);
      }
    }
  }

  // å¦‚æœæ²¡æœ‰animeIdï¼Œå…ˆæœç´¢è·å–
  if (!animeId && title) {
    try {
      const searchResult = await searchDanmu({ title, type, season, episode, server });
      if (searchResult.animes && searchResult.animes.length > 0) {
        const anime = searchResult.animes[0];
        const inferredCommentId = inferEpisodeId(anime.animeId, season, episode);
        if (inferredCommentId) {
          return await fetchDanmuComments(server, inferredCommentId);
        }
      }
    } catch (error) {
      console.error("æœç´¢å¹¶è·å–å¼¹å¹•å¤±è´¥:", error);
    }
  }

  console.warn("æ— æ³•è·å–å¼¹å¹•æ•°æ®ï¼Œç¼ºå°‘å¿…è¦å‚æ•°");
  return null;
}

// è¾…åŠ©å‡½æ•°ï¼šè·å–å¼¹å¹•è¯„è®º
async function fetchDanmuComments(server, commentId) {
  try {
    const response = await Widget.http.get(
      `${server}/api/v2/comment/${commentId}?withRelated=true&chConvert=1`,
      {
        headers: {
          "Content-Type": "application/json",
          "User-Agent": "ForwardWidgets/2.0.0",
        },
      }
    );

    if (!response) {
      throw new Error("è·å–å¼¹å¹•æ•°æ®å¤±è´¥");
    }

    return response.data;
  } catch (error) {
    console.error(`è·å–å¼¹å¹•å¤±è´¥ (commentId: ${commentId}):`, error);
    throw error;
  }
}

// è¾…åŠ©å‡½æ•°ï¼šæ¨ç†å‰§é›†ID (epid)
function inferEpisodeId(animeId, season, episode) {
  if (!animeId || !episode) {
    return null;
  }

  // æ ‡å‡†epidè®¡ç®—è§„åˆ™
  // å¤§å¤šæ•°æƒ…å†µä¸‹ï¼šanimeId + é›†æ•°ç¼–å·
  const seasonNum = season ? parseInt(season) : 1;
  const episodeNum = parseInt(episode);
  
  if (isNaN(episodeNum)) {
    return null;
  }

  // å¸¸è§çš„epidæ‹¼æ¥è§„åˆ™
  // è§„åˆ™1: animeId + é›†æ•° (æœ€å¸¸è§)
  let commentId = animeId + episodeNum.toString().padStart(2, '0');
  
  // è§„åˆ™2: å¦‚æœæœ‰å¤šå­£ï¼Œå¯èƒ½éœ€è¦è®¡ç®—åç§»
  if (seasonNum > 1) {
    // å‡è®¾æ¯å­£12é›†ï¼Œè¿™ä¸ªå¯ä»¥æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´
    const seasonOffset = (seasonNum - 1) * 12;
    const adjustedEpisode = episodeNum + seasonOffset;
    commentId = animeId + adjustedEpisode.toString().padStart(2, '0');
  }

  return commentId;
}

// è¾…åŠ©å‡½æ•°ï¼šåŒ¹é…ç•ªå‰§å­£æ•°
function matchAnimeSeason(animeTitle, originalTitle, targetSeason) {
  if (!animeTitle || !targetSeason) {
    return false;
  }

  // æ£€æŸ¥æ ‡é¢˜æ˜¯å¦åŒ…å«åŸæ ‡é¢˜
  if (!animeTitle.toLowerCase().includes(originalTitle.toLowerCase())) {
    return false;
  }

  const seasonNum = parseInt(targetSeason);
  if (isNaN(seasonNum)) {
    return false;
  }

  // ä½¿ç”¨ç©ºæ ¼åˆ†å‰²æ ‡é¢˜
  const titleParts = animeTitle.split(/\s+/);
  
  for (const part of titleParts) {
    // åŒ¹é…é˜¿æ‹‰ä¼¯æ•°å­—
    const arabicMatch = part.match(/\d+/);
    if (arabicMatch && parseInt(arabicMatch[0]) === seasonNum) {
      return true;
    }

    // åŒ¹é…ä¸­æ–‡æ•°å­—
    const chineseMatch = part.match(/[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åå£¹è²³åƒè‚†ä¼é™¸æŸ’æŒç–æ‹¾]+/);
    if (chineseMatch && convertChineseNumber(chineseMatch[0]) === seasonNum) {
      return true;
    }

    // åŒ¹é…ç½—é©¬æ•°å­—
    const romanMatch = part.match(/^(I{1,3}|IV|VI{0,3}|IX|X)$/i);
    if (romanMatch && convertRomanNumber(romanMatch[0]) === seasonNum) {
      return true;
    }
  }

  return false;
}

// ä¸­æ–‡æ•°å­—è½¬æ¢å‡½æ•°ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
function convertChineseNumber(chineseNumber) {
  if (/^\d+$/.test(chineseNumber)) {
    return parseInt(chineseNumber);
  }
  
  const digits = {
    'é›¶': 0, 'ä¸€': 1, 'äºŒ': 2, 'ä¸‰': 3, 'å››': 4, 'äº”': 5,
    'å…­': 6, 'ä¸ƒ': 7, 'å…«': 8, 'ä¹': 9,
    'å£¹': 1, 'è²³': 2, 'åƒ': 3, 'è‚†': 4, 'ä¼': 5,
    'é™¸': 6, 'æŸ’': 7, 'æŒ': 8, 'ç–': 9
  };
  
  const units = {
    'å': 10, 'ç™¾': 100, 'åƒ': 1000,
    'æ‹¾': 10, 'ä½°': 100, 'ä»Ÿ': 1000
  };
  
  let result = 0;
  let current = 0;
  let lastUnit = 1;
  
  for (let i = 0; i < chineseNumber.length; i++) {
    const char = chineseNumber[i];
    
    if (digits[char] !== undefined) {
      current = digits[char];
    } else if (units[char] !== undefined) {
      const unit = units[char];
      if (current === 0) current = 1;
      
      if (unit >= lastUnit) {
        result = current * unit;
      } else {
        result += current * unit;
      }
      
      lastUnit = unit;
      current = 0;
    }
  }
  
  if (current > 0) {
    result += current;
  }
  
  return result;
}

// ç½—é©¬æ•°å­—è½¬æ¢å‡½æ•°
function convertRomanNumber(roman) {
  const romanMap = {
    'I': 1, 'II': 2, 'III': 3, 'IV': 4, 'V': 5,
    'VI': 6, 'VII': 7, 'VIII': 8, 'IX': 9, 'X': 10
  };
  
  return romanMap[roman.toUpperCase()] || 0;
}

// æ¸…é™¤ç¼“å­˜çš„å·¥å…·å‡½æ•°ï¼ˆå¯é€‰ï¼‰
function clearAnimeCache() {
  animeCache.clear();
  console.log("ç•ªå‰§ç¼“å­˜å·²æ¸…é™¤");
}

// è·å–ç¼“å­˜çŠ¶æ€çš„å·¥å…·å‡½æ•°ï¼ˆè°ƒè¯•ç”¨ï¼‰
function getCacheStatus() {
  return {
    size: animeCache.size,
    keys: Array.from(animeCache.keys())
  };
}
