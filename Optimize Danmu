

WidgetMetadata = {
  id: "danmu.optimized",
  title: "Optimize Danmu",
  version: "2.0.0",
  requiredVersion: "0.0.2",
  description: "Optimize Danmu",
  author: "🎁 Discount Code：VEUS",
  site: "https://github.com/InchStudio/ForwardWidgets",
  globalParams: [
    {
      name: "server",
      title: "自定义服务器",
      type: "input",
      placeholders: [
        {
          title: "弹弹play",
          value: "https://api.dandanplay.net",
        },
      ],
    },
  ],
  modules: [
    {
      // id需固定为searchDanmu
      id: "searchDanmu",
      title: "搜索弹幕",
      functionName: "searchDanmu",
      type: "danmu",
      params: [],
    },
    {
      // id需固定为getDetail（保持兼容性，但实际不使用）
      id: "getDetail",
      title: "获取详情",
      functionName: "getDetailById",
      type: "danmu",
      params: [],
    },
    {
      // id需固定为getComments
      id: "getComments",
      title: "获取弹幕",
      functionName: "getCommentsById",
      type: "danmu",
      params: [],
    },
  ],
};

async function searchDanmu(params) {
  const { tmdbId, type, title, season, episode, link, videoUrl, server } = params;

  let queryTitle = title;

  try {
    // 调用弹弹play搜索API
    const response = await Widget.http.get(
      `${server}/api/v2/search/anime?keyword=${encodeURIComponent(queryTitle)}`,
      {
        headers: {
          "Content-Type": "application/json",
          "User-Agent": "ForwardWidgets/2.0.0",
        },
      }
    );

    if (!response) {
      throw new Error("获取数据失败");
    }

    const data = response.data;

    // 检查API返回状态
    if (!data.success) {
      throw new Error(data.errorMessage || "API调用失败");
    }

    // 过滤并匹配番剧
    let animes = [];
    if (data.animes && data.animes.length > 0) {
      animes = data.animes.filter((anime) => {
        // 类型匹配
        if (type === "tv" && (anime.type === "tvseries" || anime.type === "web")) {
          return true;
        } else if (type === "movie" && anime.type === "movie") {
          return true;
        }
        return false;
      });

      // 季数匹配（如果有季数信息）
      if (season && animes.length > 0) {
        const matchedAnimes = animes.filter((anime) => {
          return matchAnimeSeason(anime.animeTitle, title, season);
        });
        
        if (matchedAnimes.length > 0) {
          animes = matchedAnimes;
        }
      }

      // 为每个anime添加推理的commentId（如果有集数信息）
      if (episode) {
        animes = animes.map(anime => {
          const inferredCommentId = inferEpisodeId(anime.animeId, season, episode);
          return {
            ...anime,
            inferredCommentId: inferredCommentId
          };
        });
      }
    }

    return {
      animes: animes,
    };
  } catch (error) {
    console.error("搜索弹幕失败:", error);
    throw error;
  }
}

// 为了保持兼容性，保留getDetailById函数，但实际逻辑简化
async function getDetailById(params) {
  const { server, animeId } = params;
  
  if (!animeId) {
    return [];
  }

  try {
    const response = await Widget.http.get(
      `${server}/api/v2/bangumi/${animeId}`,
      {
        headers: {
          "Content-Type": "application/json",
          "User-Agent": "ForwardWidgets/2.0.0",
        },
      }
    );

    if (!response) {
      throw new Error("获取详情失败");
    }

    return response.data.bangumi.episodes;
  } catch (error) {
    console.error("获取详情失败:", error);
    // 即使详情获取失败，也不阻断弹幕获取流程
    return [];
  }
}

async function getCommentsById(params) {
  const { server, commentId, animeId, link, videoUrl, season, episode, tmdbId, type, title } = params;

  // 优先级1: 如果已有commentId，直接请求
  if (commentId) {
    return await fetchDanmuComments(server, commentId);
  }

  // 优先级2: 如果有animeId和episode，根据集数推理epid
  if (animeId && episode) {
    const inferredCommentId = inferEpisodeId(animeId, season, episode);
    if (inferredCommentId) {
      try {
        return await fetchDanmuComments(server, inferredCommentId);
      } catch (error) {
        console.warn(`推理的commentId ${inferredCommentId} 请求失败，尝试其他方法:`, error);
        // 推理失败时，尝试多种epid规则
        const alternativeIds = getAlternativeEpisodeIds(animeId, season, episode);
        for (const altId of alternativeIds) {
          try {
            return await fetchDanmuComments(server, altId);
          } catch (altError) {
            console.warn(`备用commentId ${altId} 也失败`);
            continue;
          }
        }
      }
    }
  }

  // 优先级3: 如果没有animeId但有title，先搜索再获取弹幕
  if (!animeId && title && episode) {
    try {
      const searchResult = await searchDanmu({ title, type, season, episode, server });
      if (searchResult.animes && searchResult.animes.length > 0) {
        const anime = searchResult.animes[0];
        
        // 尝试使用搜索时推理的commentId
        if (anime.inferredCommentId) {
          try {
            return await fetchDanmuComments(server, anime.inferredCommentId);
          } catch (error) {
            console.warn(`搜索推理的commentId失败:`, error);
          }
        }
        
        // 尝试重新推理
        const inferredCommentId = inferEpisodeId(anime.animeId, season, episode);
        if (inferredCommentId) {
          return await fetchDanmuComments(server, inferredCommentId);
        }
      }
    } catch (error) {
      console.error("搜索并获取弹幕失败:", error);
    }
  }

  console.warn("无法获取弹幕数据，缺少必要参数或所有尝试都失败了");
  return null;
}

// 辅助函数：获取弹幕评论
async function fetchDanmuComments(server, commentId) {
  try {
    const response = await Widget.http.get(
      `${server}/api/v2/comment/${commentId}?withRelated=true&chConvert=1`,
      {
        headers: {
          "Content-Type": "application/json",
          "User-Agent": "ForwardWidgets/2.0.0",
        },
      }
    );

    if (!response) {
      throw new Error("获取弹幕数据失败");
    }

    // 检查返回的数据是否有效
    if (response.data && response.data.comments && response.data.comments.length > 0) {
      return response.data;
    } else {
      throw new Error("该集数暂无弹幕数据");
    }
  } catch (error) {
    console.error(`获取弹幕失败 (commentId: ${commentId}):`, error.message);
    throw error;
  }
}

// 辅助函数：推理剧集ID (epid) - 主要规则
function inferEpisodeId(animeId, season, episode) {
  if (!animeId || !episode) {
    return null;
  }

  const seasonNum = season ? parseInt(season) : 1;
  const episodeNum = parseInt(episode);
  
  if (isNaN(episodeNum) || episodeNum < 1) {
    return null;
  }

  // 规则1: 最常见的格式 animeId + 两位数集数
  if (seasonNum <= 1) {
    return animeId + episodeNum.toString().padStart(2, '0');
  }

  // 规则2: 多季番剧，假设每季12集（可根据实际调整）
  const seasonOffset = (seasonNum - 1) * 12;
  const adjustedEpisode = episodeNum + seasonOffset;
  return animeId + adjustedEpisode.toString().padStart(2, '0');
}

// 辅助函数：获取备用的剧集ID（多种规则尝试）
function getAlternativeEpisodeIds(animeId, season, episode) {
  const alternatives = [];
  const seasonNum = season ? parseInt(season) : 1;
  const episodeNum = parseInt(episode);

  if (!animeId || isNaN(episodeNum) || episodeNum < 1) {
    return alternatives;
  }

  // 规则1: 直接拼接（无填充）
  alternatives.push(animeId + episodeNum.toString());

  // 规则2: 三位数填充
  alternatives.push(animeId + episodeNum.toString().padStart(3, '0'));

  // 规则3: 不同的季数偏移量
  if (seasonNum > 1) {
    // 每季24集的偏移
    const offset24 = (seasonNum - 1) * 24;
    alternatives.push(animeId + (episodeNum + offset24).toString().padStart(2, '0'));
    
    // 每季13集的偏移
    const offset13 = (seasonNum - 1) * 13;
    alternatives.push(animeId + (episodeNum + offset13).toString().padStart(2, '0'));
  }

  // 规则4: 特殊格式（animeId + 季数 + 集数）
  if (seasonNum > 1) {
    alternatives.push(animeId + seasonNum.toString() + episodeNum.toString().padStart(2, '0'));
  }

  return alternatives;
}

// 辅助函数：匹配番剧季数
function matchAnimeSeason(animeTitle, originalTitle, targetSeason) {
  if (!animeTitle || !targetSeason) {
    return false;
  }

  // 基础标题匹配
  const titleLower = animeTitle.toLowerCase();
  const originalLower = originalTitle.toLowerCase();
  
  if (!titleLower.includes(originalLower)) {
    return false;
  }

  const seasonNum = parseInt(targetSeason);
  if (isNaN(seasonNum)) {
    return false;
  }

  // 如果是第一季，可能不标注季数
  if (seasonNum === 1) {
    // 检查是否明确标注了其他季数
    const hasOtherSeason = /[第二三四五六七八九十2-9]\s*[季部]/i.test(animeTitle) ||
                          /season\s*[2-9]/i.test(animeTitle) ||
                          /s[2-9]/i.test(animeTitle);
    return !hasOtherSeason;
  }

  // 使用空格和常见分隔符分割标题
  const titleParts = animeTitle.split(/[\s\-_]+/);
  
  for (const part of titleParts) {
    // 匹配阿拉伯数字
    const arabicMatch = part.match(/\d+/);
    if (arabicMatch && parseInt(arabicMatch[0]) === seasonNum) {
      return true;
    }

    // 匹配中文数字
    const chineseMatch = part.match(/[第]?([一二三四五六七八九十壹貳參肆伍陸柒捌玖拾]+)[季部]/);
    if (chineseMatch && convertChineseNumber(chineseMatch[1]) === seasonNum) {
      return true;
    }

    // 匹配Season格式
    const seasonMatch = part.match(/season\s*(\d+)/i) || part.match(/s(\d+)/i);
    if (seasonMatch && parseInt(seasonMatch[1]) === seasonNum) {
      return true;
    }

    // 匹配罗马数字
    const romanMatch = part.match(/^(I{1,3}|IV|V|VI{0,3}|IX|X)$/i);
    if (romanMatch && convertRomanNumber(romanMatch[0]) === seasonNum) {
      return true;
    }
  }

  return false;
}

// 中文数字转换函数
function convertChineseNumber(chineseNumber) {
  if (/^\d+$/.test(chineseNumber)) {
    return parseInt(chineseNumber);
  }
  
  const digits = {
    '零': 0, '一': 1, '二': 2, '三': 3, '四': 4, '五': 5,
    '六': 6, '七': 7, '八': 8, '九': 9,
    '壹': 1, '貳': 2, '參': 3, '肆': 4, '伍': 5,
    '陸': 6, '柒': 7, '捌': 8, '玖': 9
  };
  
  const units = {
    '十': 10, '百': 100, '千': 1000,
    '拾': 10, '佰': 100, '仟': 1000
  };
  
  let result = 0;
  let current = 0;
  let lastUnit = 1;
  
  for (let i = 0; i < chineseNumber.length; i++) {
    const char = chineseNumber[i];
    
    if (digits[char] !== undefined) {
      current = digits[char];
    } else if (units[char] !== undefined) {
      const unit = units[char];
      if (current === 0) current = 1;
      
      if (unit >= lastUnit) {
        result = current * unit;
      } else {
        result += current * unit;
      }
      
      lastUnit = unit;
      current = 0;
    }
  }
  
  if (current > 0) {
    result += current;
  }
  
  return result;
}

// 罗马数字转换函数
function convertRomanNumber(roman) {
  const romanMap = {
    'I': 1, 'II': 2, 'III': 3, 'IV': 4, 'V': 5,
    'VI': 6, 'VII': 7, 'VIII': 8, 'IX': 9, 'X': 10
  };
  
  return romanMap[roman.toUpperCase()] || 0;
}
