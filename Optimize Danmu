

WidgetMetadata = {
  id: "danmu.optimized",
  title: "Optimize Danmu",
  version: "2.0.0",
  requiredVersion: "0.0.2",
  description: "Optimize Danmu",
  author: "ğŸ Discount Codeï¼šVEUS",
  site: "https://github.com/InchStudio/ForwardWidgets",
  globalParams: [
    {
      name: "server",
      title: "è‡ªå®šä¹‰æœåŠ¡å™¨",
      type: "input",
      placeholders: [
        {
          title: "å¼¹å¼¹play",
          value: "https://api.dandanplay.net",
        },
      ],
    },
  ],
  modules: [
    {
      // idéœ€å›ºå®šä¸ºsearchDanmu
      id: "searchDanmu",
      title: "æœç´¢å¼¹å¹•",
      functionName: "searchDanmu",
      type: "danmu",
      params: [],
    },
    {
      // idéœ€å›ºå®šä¸ºgetDetailï¼ˆä¿æŒå…¼å®¹æ€§ï¼Œä½†å®é™…ä¸ä½¿ç”¨ï¼‰
      id: "getDetail",
      title: "è·å–è¯¦æƒ…",
      functionName: "getDetailById",
      type: "danmu",
      params: [],
    },
    {
      // idéœ€å›ºå®šä¸ºgetComments
      id: "getComments",
      title: "è·å–å¼¹å¹•",
      functionName: "getCommentsById",
      type: "danmu",
      params: [],
    },
  ],
};

async function searchDanmu(params) {
  const { tmdbId, type, title, season, episode, link, videoUrl, server } = params;

  let queryTitle = title;

  try {
    // è°ƒç”¨å¼¹å¼¹playæœç´¢API
    const response = await Widget.http.get(
      `${server}/api/v2/search/anime?keyword=${encodeURIComponent(queryTitle)}`,
      {
        headers: {
          "Content-Type": "application/json",
          "User-Agent": "ForwardWidgets/2.0.0",
        },
      }
    );

    if (!response) {
      throw new Error("è·å–æ•°æ®å¤±è´¥");
    }

    const data = response.data;

    // æ£€æŸ¥APIè¿”å›çŠ¶æ€
    if (!data.success) {
      throw new Error(data.errorMessage || "APIè°ƒç”¨å¤±è´¥");
    }

    // è¿‡æ»¤å¹¶åŒ¹é…ç•ªå‰§
    let animes = [];
    if (data.animes && data.animes.length > 0) {
      animes = data.animes.filter((anime) => {
        // ç±»å‹åŒ¹é…
        if (type === "tv" && (anime.type === "tvseries" || anime.type === "web")) {
          return true;
        } else if (type === "movie" && anime.type === "movie") {
          return true;
        }
        return false;
      });

      // å­£æ•°åŒ¹é…ï¼ˆå¦‚æœæœ‰å­£æ•°ä¿¡æ¯ï¼‰
      if (season && animes.length > 0) {
        const matchedAnimes = animes.filter((anime) => {
          return matchAnimeSeason(anime.animeTitle, title, season);
        });
        
        if (matchedAnimes.length > 0) {
          animes = matchedAnimes;
        }
      }

      // ä¸ºæ¯ä¸ªanimeæ·»åŠ æ¨ç†çš„commentIdï¼ˆå¦‚æœæœ‰é›†æ•°ä¿¡æ¯ï¼‰
      if (episode) {
        animes = animes.map(anime => {
          const inferredCommentId = inferEpisodeId(anime.animeId, season, episode);
          return {
            ...anime,
            inferredCommentId: inferredCommentId
          };
        });
      }
    }

    return {
      animes: animes,
    };
  } catch (error) {
    console.error("æœç´¢å¼¹å¹•å¤±è´¥:", error);
    throw error;
  }
}

// ä¸ºäº†ä¿æŒå…¼å®¹æ€§ï¼Œä¿ç•™getDetailByIdå‡½æ•°ï¼Œä½†å®é™…é€»è¾‘ç®€åŒ–
async function getDetailById(params) {
  const { server, animeId } = params;
  
  if (!animeId) {
    return [];
  }

  try {
    const response = await Widget.http.get(
      `${server}/api/v2/bangumi/${animeId}`,
      {
        headers: {
          "Content-Type": "application/json",
          "User-Agent": "ForwardWidgets/2.0.0",
        },
      }
    );

    if (!response) {
      throw new Error("è·å–è¯¦æƒ…å¤±è´¥");
    }

    return response.data.bangumi.episodes;
  } catch (error) {
    console.error("è·å–è¯¦æƒ…å¤±è´¥:", error);
    // å³ä½¿è¯¦æƒ…è·å–å¤±è´¥ï¼Œä¹Ÿä¸é˜»æ–­å¼¹å¹•è·å–æµç¨‹
    return [];
  }
}

async function getCommentsById(params) {
  const { server, commentId, animeId, link, videoUrl, season, episode, tmdbId, type, title } = params;

  // ä¼˜å…ˆçº§1: å¦‚æœå·²æœ‰commentIdï¼Œç›´æ¥è¯·æ±‚
  if (commentId) {
    return await fetchDanmuComments(server, commentId);
  }

  // ä¼˜å…ˆçº§2: å¦‚æœæœ‰animeIdå’Œepisodeï¼Œæ ¹æ®é›†æ•°æ¨ç†epid
  if (animeId && episode) {
    const inferredCommentId = inferEpisodeId(animeId, season, episode);
    if (inferredCommentId) {
      try {
        return await fetchDanmuComments(server, inferredCommentId);
      } catch (error) {
        console.warn(`æ¨ç†çš„commentId ${inferredCommentId} è¯·æ±‚å¤±è´¥ï¼Œå°è¯•å…¶ä»–æ–¹æ³•:`, error);
        // æ¨ç†å¤±è´¥æ—¶ï¼Œå°è¯•å¤šç§epidè§„åˆ™
        const alternativeIds = getAlternativeEpisodeIds(animeId, season, episode);
        for (const altId of alternativeIds) {
          try {
            return await fetchDanmuComments(server, altId);
          } catch (altError) {
            console.warn(`å¤‡ç”¨commentId ${altId} ä¹Ÿå¤±è´¥`);
            continue;
          }
        }
      }
    }
  }

  // ä¼˜å…ˆçº§3: å¦‚æœæ²¡æœ‰animeIdä½†æœ‰titleï¼Œå…ˆæœç´¢å†è·å–å¼¹å¹•
  if (!animeId && title && episode) {
    try {
      const searchResult = await searchDanmu({ title, type, season, episode, server });
      if (searchResult.animes && searchResult.animes.length > 0) {
        const anime = searchResult.animes[0];
        
        // å°è¯•ä½¿ç”¨æœç´¢æ—¶æ¨ç†çš„commentId
        if (anime.inferredCommentId) {
          try {
            return await fetchDanmuComments(server, anime.inferredCommentId);
          } catch (error) {
            console.warn(`æœç´¢æ¨ç†çš„commentIdå¤±è´¥:`, error);
          }
        }
        
        // å°è¯•é‡æ–°æ¨ç†
        const inferredCommentId = inferEpisodeId(anime.animeId, season, episode);
        if (inferredCommentId) {
          return await fetchDanmuComments(server, inferredCommentId);
        }
      }
    } catch (error) {
      console.error("æœç´¢å¹¶è·å–å¼¹å¹•å¤±è´¥:", error);
    }
  }

  console.warn("æ— æ³•è·å–å¼¹å¹•æ•°æ®ï¼Œç¼ºå°‘å¿…è¦å‚æ•°æˆ–æ‰€æœ‰å°è¯•éƒ½å¤±è´¥äº†");
  return null;
}

// è¾…åŠ©å‡½æ•°ï¼šè·å–å¼¹å¹•è¯„è®º
async function fetchDanmuComments(server, commentId) {
  try {
    const response = await Widget.http.get(
      `${server}/api/v2/comment/${commentId}?withRelated=true&chConvert=1`,
      {
        headers: {
          "Content-Type": "application/json",
          "User-Agent": "ForwardWidgets/2.0.0",
        },
      }
    );

    if (!response) {
      throw new Error("è·å–å¼¹å¹•æ•°æ®å¤±è´¥");
    }

    // æ£€æŸ¥è¿”å›çš„æ•°æ®æ˜¯å¦æœ‰æ•ˆ
    if (response.data && response.data.comments && response.data.comments.length > 0) {
      return response.data;
    } else {
      throw new Error("è¯¥é›†æ•°æš‚æ— å¼¹å¹•æ•°æ®");
    }
  } catch (error) {
    console.error(`è·å–å¼¹å¹•å¤±è´¥ (commentId: ${commentId}):`, error.message);
    throw error;
  }
}

// è¾…åŠ©å‡½æ•°ï¼šæ¨ç†å‰§é›†ID (epid) - ä¸»è¦è§„åˆ™
function inferEpisodeId(animeId, season, episode) {
  if (!animeId || !episode) {
    return null;
  }

  const seasonNum = season ? parseInt(season) : 1;
  const episodeNum = parseInt(episode);
  
  if (isNaN(episodeNum) || episodeNum < 1) {
    return null;
  }

  // è§„åˆ™1: æœ€å¸¸è§çš„æ ¼å¼ animeId + ä¸¤ä½æ•°é›†æ•°
  if (seasonNum <= 1) {
    return animeId + episodeNum.toString().padStart(2, '0');
  }

  // è§„åˆ™2: å¤šå­£ç•ªå‰§ï¼Œå‡è®¾æ¯å­£12é›†ï¼ˆå¯æ ¹æ®å®é™…è°ƒæ•´ï¼‰
  const seasonOffset = (seasonNum - 1) * 12;
  const adjustedEpisode = episodeNum + seasonOffset;
  return animeId + adjustedEpisode.toString().padStart(2, '0');
}

// è¾…åŠ©å‡½æ•°ï¼šè·å–å¤‡ç”¨çš„å‰§é›†IDï¼ˆå¤šç§è§„åˆ™å°è¯•ï¼‰
function getAlternativeEpisodeIds(animeId, season, episode) {
  const alternatives = [];
  const seasonNum = season ? parseInt(season) : 1;
  const episodeNum = parseInt(episode);

  if (!animeId || isNaN(episodeNum) || episodeNum < 1) {
    return alternatives;
  }

  // è§„åˆ™1: ç›´æ¥æ‹¼æ¥ï¼ˆæ— å¡«å……ï¼‰
  alternatives.push(animeId + episodeNum.toString());

  // è§„åˆ™2: ä¸‰ä½æ•°å¡«å……
  alternatives.push(animeId + episodeNum.toString().padStart(3, '0'));

  // è§„åˆ™3: ä¸åŒçš„å­£æ•°åç§»é‡
  if (seasonNum > 1) {
    // æ¯å­£24é›†çš„åç§»
    const offset24 = (seasonNum - 1) * 24;
    alternatives.push(animeId + (episodeNum + offset24).toString().padStart(2, '0'));
    
    // æ¯å­£13é›†çš„åç§»
    const offset13 = (seasonNum - 1) * 13;
    alternatives.push(animeId + (episodeNum + offset13).toString().padStart(2, '0'));
  }

  // è§„åˆ™4: ç‰¹æ®Šæ ¼å¼ï¼ˆanimeId + å­£æ•° + é›†æ•°ï¼‰
  if (seasonNum > 1) {
    alternatives.push(animeId + seasonNum.toString() + episodeNum.toString().padStart(2, '0'));
  }

  return alternatives;
}

// è¾…åŠ©å‡½æ•°ï¼šåŒ¹é…ç•ªå‰§å­£æ•°
function matchAnimeSeason(animeTitle, originalTitle, targetSeason) {
  if (!animeTitle || !targetSeason) {
    return false;
  }

  // åŸºç¡€æ ‡é¢˜åŒ¹é…
  const titleLower = animeTitle.toLowerCase();
  const originalLower = originalTitle.toLowerCase();
  
  if (!titleLower.includes(originalLower)) {
    return false;
  }

  const seasonNum = parseInt(targetSeason);
  if (isNaN(seasonNum)) {
    return false;
  }

  // å¦‚æœæ˜¯ç¬¬ä¸€å­£ï¼Œå¯èƒ½ä¸æ ‡æ³¨å­£æ•°
  if (seasonNum === 1) {
    // æ£€æŸ¥æ˜¯å¦æ˜ç¡®æ ‡æ³¨äº†å…¶ä»–å­£æ•°
    const hasOtherSeason = /[ç¬¬äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹å2-9]\s*[å­£éƒ¨]/i.test(animeTitle) ||
                          /season\s*[2-9]/i.test(animeTitle) ||
                          /s[2-9]/i.test(animeTitle);
    return !hasOtherSeason;
  }

  // ä½¿ç”¨ç©ºæ ¼å’Œå¸¸è§åˆ†éš”ç¬¦åˆ†å‰²æ ‡é¢˜
  const titleParts = animeTitle.split(/[\s\-_]+/);
  
  for (const part of titleParts) {
    // åŒ¹é…é˜¿æ‹‰ä¼¯æ•°å­—
    const arabicMatch = part.match(/\d+/);
    if (arabicMatch && parseInt(arabicMatch[0]) === seasonNum) {
      return true;
    }

    // åŒ¹é…ä¸­æ–‡æ•°å­—
    const chineseMatch = part.match(/[ç¬¬]?([ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åå£¹è²³åƒè‚†ä¼é™¸æŸ’æŒç–æ‹¾]+)[å­£éƒ¨]/);
    if (chineseMatch && convertChineseNumber(chineseMatch[1]) === seasonNum) {
      return true;
    }

    // åŒ¹é…Seasonæ ¼å¼
    const seasonMatch = part.match(/season\s*(\d+)/i) || part.match(/s(\d+)/i);
    if (seasonMatch && parseInt(seasonMatch[1]) === seasonNum) {
      return true;
    }

    // åŒ¹é…ç½—é©¬æ•°å­—
    const romanMatch = part.match(/^(I{1,3}|IV|V|VI{0,3}|IX|X)$/i);
    if (romanMatch && convertRomanNumber(romanMatch[0]) === seasonNum) {
      return true;
    }
  }

  return false;
}

// ä¸­æ–‡æ•°å­—è½¬æ¢å‡½æ•°
function convertChineseNumber(chineseNumber) {
  if (/^\d+$/.test(chineseNumber)) {
    return parseInt(chineseNumber);
  }
  
  const digits = {
    'é›¶': 0, 'ä¸€': 1, 'äºŒ': 2, 'ä¸‰': 3, 'å››': 4, 'äº”': 5,
    'å…­': 6, 'ä¸ƒ': 7, 'å…«': 8, 'ä¹': 9,
    'å£¹': 1, 'è²³': 2, 'åƒ': 3, 'è‚†': 4, 'ä¼': 5,
    'é™¸': 6, 'æŸ’': 7, 'æŒ': 8, 'ç–': 9
  };
  
  const units = {
    'å': 10, 'ç™¾': 100, 'åƒ': 1000,
    'æ‹¾': 10, 'ä½°': 100, 'ä»Ÿ': 1000
  };
  
  let result = 0;
  let current = 0;
  let lastUnit = 1;
  
  for (let i = 0; i < chineseNumber.length; i++) {
    const char = chineseNumber[i];
    
    if (digits[char] !== undefined) {
      current = digits[char];
    } else if (units[char] !== undefined) {
      const unit = units[char];
      if (current === 0) current = 1;
      
      if (unit >= lastUnit) {
        result = current * unit;
      } else {
        result += current * unit;
      }
      
      lastUnit = unit;
      current = 0;
    }
  }
  
  if (current > 0) {
    result += current;
  }
  
  return result;
}

// ç½—é©¬æ•°å­—è½¬æ¢å‡½æ•°
function convertRomanNumber(roman) {
  const romanMap = {
    'I': 1, 'II': 2, 'III': 3, 'IV': 4, 'V': 5,
    'VI': 6, 'VII': 7, 'VIII': 8, 'IX': 9, 'X': 10
  };
  
  return romanMap[roman.toUpperCase()] || 0;
}
