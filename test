/* ==================  WidgetMetadata  ================== */
var WidgetMetadata = {
  id: "xtream_api_enhance",
  title: "Xtream API Live",
  description: "Fetch live channels via official Xtream-Codes REST API with keyword search",
  author: "VEUS",
  site: "https://github.com/InchStudio/ForwardWidgets",
  version: "2.8.5",
  requiredVersion: "0.0.1",
  detailCacheDuration: 60,
  modules: [
    {
      title: "Channel List",
      description: "REST API â†’ channel cards",
      requiresWebView: false,
      functionName: "getChannels",
      cacheDuration: 300,
      params: [
        { name: "m3u_url",  type: "input",  placeholder: "http://host/get.php?username=xxx&password=xxx&type=m3u_plus" },
        { name: "host",     type: "input",  placeholder: "lot77162.cdngold.me" },
        { name: "username", type: "input" },
        { name: "password", type: "input" },
        { name: "keyword",  type: "input",  placeholder: "CCTV, Sports..." },
        { name: "protocol", type: "enumeration", enumOptions: [
            { title: "HTTP",  value: "http"  },
            { title: "HTTPS", value: "https" }
          ], default: "http" },
        { name: "ua", type: "input", placeholder: "Forward/1.3.2" }
      ]
    }
  ]
};

/* ==================  ä¸»å…¥å£ï¼šä»…è¿”å›åˆ†ç±»  ================== */
async function getChannels(params = {}) {
  /* 1. å‚æ•°è§£æï¼ˆæ”¯æŒ m3u_urlï¼‰ */
  let { host, username, password, ua, protocol } = params;
  if (!host && params.m3u_url) {
    const p = parseM3uUrl(params.m3u_url);
    if (p) ({ host, username, password, protocol } = p);
  }
  if (!host || !username || !password) {
    throw new Error("host / username / password are required");
  }

  const UA = ua || "Forward/1.3.2";
  const base = `${protocol}://${host}/player_api.php?username=${username}&password=${password}`;

  /* 2. æ‹‰å–åˆ†ç±» */
  const [liveCats, vodCats, serCats] = await Promise.all([
    api(`${base}&action=get_live_categories`, UA),
    api(`${base}&action=get_vod_categories`, UA),
    api(`${base}&action=get_series_categories`, UA)
  ]);

  /* 3. è¿”å›åˆ†ç±»å…¥å£å¡ç‰‡ï¼ˆtype=linkï¼‰ */
  return [
    ...liveCats.map(c => makeCategoryCard("ğŸ“º Live",  c, "live"  , base, UA)),
    ...vodCats .map(c => makeCategoryCard("ğŸ¬ VOD",   c, "vod"   , base, UA)),
    ...serCats .map(c => makeCategoryCard("ğŸ“º Series",c, "series", base, UA))
  ];
}

/* ==================  äºŒçº§å‡½æ•°ï¼šåˆ†ç±»ä¸‹å†…å®¹  ================== */
/* Forward è°ƒç”¨æ—¶å›ºå®šä¼ å‚ï¼šparams = {catId, type, host, username, password, ua, protocol, keyword} */
async function getStreamsByCat(params) {
  const { catId, type, host, username, password, ua, protocol, keyword = "" } = params;
  const UA   = ua || "Forward/1.3.2";
  const base = `${protocol}://${host}/player_api.php?username=${username}&password=${password}`;
  const kw   = keyword.trim().toLowerCase();

  let list = [];
  if (type === "live") {
    list = filter(await api(`${base}&action=get_live_streams&category_id=${catId}`, UA), kw);
  } else if (type === "vod") {
    list = filter(await api(`${base}&action=get_vod_streams&category_id=${catId}`, UA), kw);
  } else if (type === "series") {
    list = filter(await api(`${base}&action=get_series&category_id=${catId}`, UA), kw);
  }

  /* ç»Ÿä¸€è½¬ä¸ºæ ‡å‡† VideoItem */
  return list.map(it => ({
    id: `${type}_${it.stream_id || it.series_id}`,
    type: "url",
    title: it.name,
    description: it.category_name || "",
    posterPath: it.stream_icon || "",
    backdropPath: it.stream_icon || "",
    mediaType: type === "live" ? "tv" : "movie",
    videoUrl: `${base.replace("player_api.php", type)}/${it.stream_id || it.series_id}.${type === "live" ? "ts" : (it.container_extension || "mp4")}`
  }));
}

/* ==================  å·¥å…·å‡½æ•°  ================== */
function parseM3uUrl(raw) {
  try {
    const u = new URL(raw);
    return {
      protocol: u.protocol.slice(0, -1),
      host: u.hostname,
      username: u.searchParams.get("username"),
      password: u.searchParams.get("password")
    };
  } catch { return null; }
async function api(url, ua) {
  try {
    const res = await Widget.http.get(url, { headers: { "User-Agent": ua } });
    return Array.isArray(res.data) ? res.data : [];
  } catch (e) {
    console.error("Request failed:", e);
    throw new Error("ç½‘ç»œè¯·æ±‚å¤±è´¥");
  }
}
function filter(arr, kw) {
  return kw ? arr.filter(i => (i.name || "").toLowerCase().includes(kw)) : arr;
}
function makeCategoryCard(icon, cat, type, base, UA) {
  const host = base.match(/https?:\/\/([^\/]+)/)[1];
  const usr = base.match(/username=([^&]+)/)[1];
  const pwd = base.match(/password=([^&]+)/)[1];
  const prot = base.split("://")[0];
  return {
    id: `${type}_cat_${cat.category_id}`,
    type: "link",                                   // â† å…³é”®ï¼šå¿…é¡»æ˜¯ link
    title: `${icon} ${cat.category_name}`,
    description: `ç‚¹å‡»æŸ¥çœ‹ ${type} åˆ—è¡¨`,
    posterPath: `https://fakeimg.pl/200x120/1C1C1E/?text=${encodeURIComponent(cat.category_name)}`,
    link: `js:getStreamsByCat({type:"${type}",catId:${cat.category_id},host:"${host}",username:"${usr}",password:"${pwd}",protocol:"${prot}",ua:"${UA}"})`
  };
}
