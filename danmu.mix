
var WidgetMetadata = {
  id: "danmuServe",
  title: "danmuServe",
  description: "",
  author: "üéÅ Discount CodeÔºöVEUS",
  site: "https://github.com/InchStudio/ForwardWidgets",
  version: "2.0.0",
  requiredVersion: "0.0.2",
  detailCacheDuration: 60,
  globalParams: [
    {
      name: "server1",
      title: "ÈªòËÆ§",
      type: "input",
      placeholders: [
        {
          title: "Á§∫‰æã",
          value: "",
        },
      ],
    },
    {
      name: "server2",
      title: "Á¨¨‰∫åÂºπÂπïÊ∫ê",
      type: "input",
      placeholders: [
        {
          title: "Á§∫‰æã: http://example.com:7768/api/token123",
          value: "",
        },
      ],
    },
    {
      name: "server3",
      title: "Á¨¨‰∏âÂºπÂπïÊ∫ê",
      type: "input",
      placeholders: [
        {
          title: "Á§∫‰æã: http://example.com:8080/api/token456",
          value: "",
        },
      ],
    },
    {
      name: "server4",
      title: "Á¨¨ÂõõÂºπÂπïÊ∫ê",
      type: "input",
      placeholders: [
        {
          title: "Á§∫‰æã: http://example.com:9090/api/token789",
          value: "",
        },
      ],
    },
    {
      name: "server5",
      title: "Á¨¨‰∫îÂºπÂπïÊ∫ê",
      type: "input",
      placeholders: [
        {
          title: "Á§∫‰æã: http://example.com:3000/api/tokenABC",
          value: "",
        },
      ],
    },
    {
      name: "enabledSources",
      title: "ÂêØÁî®ÁöÑÂºπÂπïÊ∫ê",
      type: "enumeration",
      enumOptions: [
        { title: "ÂÖ®ÈÉ®ÂêØÁî®", value: "all" },
        { title: "‰ªÖ‰∏ªÊ∫ê", value: "primary" },
        { title: "‰∏ªÊ∫ê+Á¨¨‰∫åÊ∫ê", value: "two" },
        { title: "Ââç‰∏â‰∏™Ê∫ê", value: "three" },
        { title: "Ëá™ÂÆö‰πâ(1,3,5)", value: "custom" }
      ],
      value: "all"
    },
    {
      name: "mergeMode",
      title: "ÂêàÂπ∂Ê®°Âºè",
      type: "enumeration",
      enumOptions: [
        { title: "ÂÖ®ÈÉ®ÂêàÂπ∂", value: "merge" },
        { title: "‰ºòÂÖàÁ∫ß", value: "priority" },
        { title: "Á¨¨‰∏ÄÊàêÂäü", value: "first" }
      ],
      value: "merge"
    }
  ],
  modules: [
    {
      id: "searchDanmu",
      title: "ÊêúÁ¥¢ÂºπÂπï",
      functionName: "searchDanmu",
      type: "danmu",
      cacheDuration: 3600,
      params: []
    },
    {
      id: "getDetail",
      title: "Ëé∑ÂèñËØ¶ÊÉÖ",
      functionName: "getDetailById",
      type: "danmu",
      cacheDuration: 3600,
      params: []
    },
    {
      id: "getComments",
      title: "Ëé∑ÂèñÂºπÂπï",
      functionName: "getCommentsById",
      type: "danmu",
      cacheDuration: 300,
      params: []
    }
  ]
};

// ÂºπÂπïÊ∫êÈÖçÁΩÆ
const SOURCES_CONFIG = [
  { name: "ÂºπÂºπplay", key: "server1", type: "dandanplay" },
  { name: "Á¨¨‰∫åÊ∫ê", key: "server2", type: "direct_api" },
  { name: "Á¨¨‰∏âÊ∫ê", key: "server3", type: "direct_api" },
  { name: "Á¨¨ÂõõÊ∫ê", key: "server4", type: "direct_api" },
  { name: "Á¨¨‰∫îÊ∫ê", key: "server5", type: "direct_api" }
];

async function searchDanmu(params = {}) {
  try {
    const { 
      tmdbId, type, title, season, 
      server1, server2, server3, server4, server5,
      enabledSources, mergeMode 
    } = params;

    // ÂèÇÊï∞È™åËØÅ
    if (!title) {
      throw new Error("Áº∫Â∞ëÂøÖË¶ÅÂèÇÊï∞: title");
    }

    console.log(`ÂºÄÂßãÊêúÁ¥¢ÂºπÂπï: ${title}`);

    const servers = { server1, server2, server3, server4, server5 };
    const enabledList = getEnabledSourcesList(enabledSources || "all");
    const promises = [];
    let allAnimes = [];

    // ‰∏∫ÊØè‰∏™ÂêØÁî®ÁöÑÊ∫êÂàõÂª∫ÊêúÁ¥¢‰ªªÂä°
    enabledList.forEach(sourceIndex => {
      const config = SOURCES_CONFIG[sourceIndex];
      const serverUrl = servers[config.key];
      
      if (serverUrl) {
        if (config.type === "dandanplay") {
          promises.push(searchFromDandanplay(serverUrl, params, sourceIndex));
        } else {
          promises.push(searchFromDirectApi(serverUrl, params, sourceIndex));
        }
      }
    });

    if (promises.length === 0) {
      console.log("Ê≤°ÊúâÂèØÁî®ÁöÑÂºπÂπïÊ∫ê");
      return { animes: [] };
    }

    // Âπ∂ÂèëË∞ÉÁî®ÊâÄÊúâAPIÊ∫ê
    const results = await Promise.allSettled(promises);
    
    // ÂêàÂπ∂ÁªìÊûú
    results.forEach((result, index) => {
      if (result.status === "fulfilled" && result.value && result.value.animes) {
        const sourceIndex = enabledList[index];
        const animesWithSource = result.value.animes.map(anime => ({
          ...anime,
          _sourceIndex: sourceIndex
        }));
        allAnimes = allAnimes.concat(animesWithSource);
        console.log(`Ê∫ê${sourceIndex + 1}ËøîÂõû${animesWithSource.length}‰∏™ÁªìÊûú`);
      } else if (result.status === "rejected") {
        console.error(`Ê∫ê${enabledList[index] + 1}ÊêúÁ¥¢Â§±Ë¥•:`, result.reason?.message);
      }
    });

    // ÂéªÈáçÂ§ÑÁêÜ
    allAnimes = removeDuplicateResults(allAnimes);
    
    console.log(`ÊêúÁ¥¢ÂÆåÊàêÔºåÂÖ±ËøîÂõû${allAnimes.length}‰∏™ÁªìÊûú`);
    
    return { animes: allAnimes };

  } catch (error) {
    console.error("ÊêúÁ¥¢ÂºπÂπïÂ§±Ë¥•:", error);
    throw error;
  }
}

// Ëé∑ÂèñÂêØÁî®ÁöÑÊ∫êÂàóË°®
function getEnabledSourcesList(enabledSources) {
  switch (enabledSources) {
    case "all":
      return [0, 1, 2, 3, 4];
    case "primary":
      return [0];
    case "two":
      return [0, 1];
    case "three":
      return [0, 1, 2];
    case "custom":
      return [0, 2, 4]; // 1,3,5Ê∫ê
    default:
      return [0];
  }
}

// ÂºπÂºπplayÊêúÁ¥¢
async function searchFromDandanplay(serverUrl, params, sourceIndex) {
  try {
    const { type, title, season } = params;
    
    console.log(`Ê∫ê${sourceIndex + 1}(ÂºπÂºπplay)ÂºÄÂßãÊêúÁ¥¢: ${title}`);

    const response = await Widget.http.get(
      `${serverUrl}/api/v2/search/anime?keyword=${encodeURIComponent(title)}`,
      {
        headers: {
          "Content-Type": "application/json",
          "User-Agent": "ForwardWidgets/1.0.0"
        }
      }
    );

    if (!response || !response.data) {
      throw new Error("ÂºπÂºπplayÂìçÂ∫îÊï∞ÊçÆ‰∏∫Á©∫");
    }

    const data = response.data;
    if (!data.success) {
      throw new Error(data.errorMessage || "ÂºπÂºπplay APIË∞ÉÁî®Â§±Ë¥•");
    }

    let animes = [];
    if (data.animes && data.animes.length > 0) {
      animes = data.animes.filter(anime => {
        if ((anime.type === "tvseries" || anime.type === "web") && type === "tv") {
          return true;
        } else if (anime.type === "movie" && type === "movie") {
          return true;
        }
        return false;
      });
      
      // Â≠£Êï∞ÂåπÈÖçÂ§ÑÁêÜ
      if (season && animes.length > 0) {
        const matchedAnimes = animes.filter(anime => {
          if (anime.animeTitle.includes(title)) {
            const titleParts = anime.animeTitle.split(" ");
            if (titleParts.length > 1) {
              const seasonPart = titleParts[1];
              const seasonIndex = seasonPart.match(/\d+/);
              if (seasonIndex && seasonIndex[0] === season) {
                return true;
              }
              const chineseNumber = seasonPart.match(/[‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅÂ£πË¥∞ÂèÅËÇÜ‰ºçÈôÜÊüíÊçåÁéñÊãæ]+/);
              if (chineseNumber && convertChineseNumber(chineseNumber[0]) === season) {
                return true;
              }
            }
          }
          return false;
        });
        
        if (matchedAnimes.length > 0) {
          animes = matchedAnimes;
        }
      }
    }
    
    console.log(`ÂºπÂºπplayÊêúÁ¥¢ÂÆåÊàêÔºåÊâæÂà∞${animes.length}‰∏™ÁªìÊûú`);
    return { animes: animes };

  } catch (error) {
    console.error("ÂºπÂºπplayÊêúÁ¥¢Â§±Ë¥•:", error);
    throw error;
  }
}

// Áõ¥Êé•APIÊêúÁ¥¢ÔºàÈÄÇÈÖçÁ±ª‰ºº http://host:port/api/token Ê†ºÂºèÔºâ
async function searchFromDirectApi(serverUrl, params, sourceIndex) {
  try {
    const { type, title } = params;
    
    console.log(`Ê∫ê${sourceIndex + 1}ÂºÄÂßãÊêúÁ¥¢: ${title}`);

    // Áõ¥Êé•‰ΩøÁî®Êèê‰æõÁöÑÂÆåÊï¥APIÂú∞ÂùÄÔºåÂèØËÉΩÂ∑≤ÂåÖÂê´token
    let response;
    
    // Â∞ùËØïÊñπÂºè1: ‰Ωú‰∏∫Êü•ËØ¢ÂèÇÊï∞
    try {
      response = await Widget.http.get(`${serverUrl}?keyword=${encodeURIComponent(title)}&type=${type}`, {
        headers: {
          "Content-Type": "application/json",
          "User-Agent": "ForwardWidgets/1.0.0"
        }
      });
    } catch (e1) {
      // Â∞ùËØïÊñπÂºè2: POSTËØ∑Ê±Ç
      try {
        response = await Widget.http.post(serverUrl, {
          keyword: title,
          type: type
        }, {
          headers: {
            "Content-Type": "application/json",
            "User-Agent": "ForwardWidgets/1.0.0"
          }
        });
      } catch (e2) {
        // Â∞ùËØïÊñπÂºè3: Áõ¥Êé•GETÔºàÂèØËÉΩAPIËá™Ë∫´ÂåÖÂê´ÊâÄÈúÄÂèÇÊï∞Ôºâ
        response = await Widget.http.get(serverUrl, {
          headers: {
            "Content-Type": "application/json",
            "User-Agent": "ForwardWidgets/1.0.0"
          }
        });
      }
    }

    if (!response || !response.data) {
      throw new Error(`Ê∫ê${sourceIndex + 1}ÂìçÂ∫îÊï∞ÊçÆ‰∏∫Á©∫`);
    }

    // ËΩ¨Êç¢‰∏çÂêåÊ∫êÁöÑËøîÂõûÊ†ºÂºè‰∏∫Ê†áÂáÜÊ†ºÂºè
    const animes = convertDirectApiResponse(response.data, sourceIndex);
    
    console.log(`Ê∫ê${sourceIndex + 1}ÊêúÁ¥¢ÂÆåÊàêÔºåÊâæÂà∞${animes.length}‰∏™ÁªìÊûú`);
    return { animes: animes };

  } catch (error) {
    console.error(`Ê∫ê${sourceIndex + 1}ÊêúÁ¥¢Â§±Ë¥•:`, error);
    throw error;
  }
}

// ËΩ¨Êç¢Áõ¥Êé•APIÁöÑËøîÂõûÊ†ºÂºè‰∏∫Ê†áÂáÜÊ†ºÂºè
function convertDirectApiResponse(data, sourceIndex) {
  try {
    let animes = [];
    
    // Â∞ùËØïËØÜÂà´Â∏∏ËßÅÁöÑÂìçÂ∫îÊ†ºÂºè
    if (data.animes) {
      // Á±ª‰ººÂºπÂºπplayÊ†ºÂºè
      animes = data.animes;
    } else if (data.results) {
      // resultsÊ†ºÂºè
      animes = data.results.map(item => ({
        animeId: item.id || item.animeId || item.bangumi_id,
        animeTitle: item.title || item.name || item.animeTitle,
        type: item.type || "tvseries",
        episodeCount: item.episode_count || item.episodes || item.episodeCount || 0
      }));
    } else if (data.data) {
      // dataÊ†ºÂºè
      animes = data.data.map(item => ({
        animeId: item.id || item.anime_id || item.bangumi_id,
        animeTitle: item.title || item.name || item.anime_title,
        type: item.type || item.category || "tvseries",
        episodeCount: item.episode_count || item.episodes || 0
      }));
    } else if (data.list) {
      // listÊ†ºÂºè
      animes = data.list.map(item => ({
        animeId: item.id || item.bangumi_id,
        animeTitle: item.title || item.name || item.bangumi_name,
        type: item.type || item.kind || "tvseries",
        episodeCount: item.episode_count || item.ep_count || 0
      }));
    } else if (Array.isArray(data)) {
      // Áõ¥Êé•Êï∞ÁªÑÊ†ºÂºè
      animes = data.map(item => ({
        animeId: item.id || item.animeId,
        animeTitle: item.title || item.name || item.animeTitle,
        type: item.type || "tvseries",
        episodeCount: item.episode_count || item.episodes || 0
      }));
    }
    
    return animes;
  } catch (error) {
    console.error(`Ê∫ê${sourceIndex + 1}Êï∞ÊçÆËΩ¨Êç¢Â§±Ë¥•:`, error);
    return [];
  }
}

// ÂéªÈáçÂ§ÑÁêÜ
function removeDuplicateResults(animes) {
  const seen = new Map();
  return animes.filter(anime => {
    const key = `${anime.animeTitle?.toLowerCase()?.trim()}-${anime.type}`;
    if (seen.has(key)) {
      const existing = seen.get(key);
      if (anime._sourceIndex < existing._sourceIndex) {
        seen.set(key, anime);
        return true;
      }
      return false;
    }
    seen.set(key, anime);
    return true;
  });
}

// ‰∏≠ÊñáÊï∞Â≠óËΩ¨Êç¢
function convertChineseNumber(chineseNumber) {
  if (/^\d+$/.test(chineseNumber)) {
    return Number(chineseNumber);
  }
  
  const digits = {
    'Èõ∂': 0, '‰∏Ä': 1, '‰∫å': 2, '‰∏â': 3, 'Âõõ': 4, '‰∫î': 5,
    'ÂÖ≠': 6, '‰∏É': 7, 'ÂÖ´': 8, '‰πù': 9,
    'Â£π': 1, 'Ë≤≥': 2, 'ÂèÉ': 3, 'ËÇÜ': 4, '‰ºç': 5,
    'Èô∏': 6, 'Êüí': 7, 'Êçå': 8, 'Áéñ': 9
  };
  
  const units = {
    'ÂçÅ': 10, 'Áôæ': 100, 'ÂçÉ': 1000,
    'Êãæ': 10, '‰Ω∞': 100, '‰ªü': 1000
  };
  
  let result = 0;
  let current = 0;
  let lastUnit = 1;
  
  for (let i = 0; i < chineseNumber.length; i++) {
    const char = chineseNumber[i];
    
    if (digits[char] !== undefined) {
      current = digits[char];
    } else if (units[char] !== undefined) {
      const unit = units[char];
      
      if (current === 0) current = 1;
      
      if (unit >= lastUnit) {
        result = current * unit;
      } else {
        result += current * unit;
      }
      
      lastUnit = unit;
      current = 0;
    }
  }
  
  if (current > 0) {
    result += current;
  }
  
  return result;
}

async function getDetailById(params = {}) {
  try {
    const { 
      server1, server2, server3, server4, server5,
      animeId, _sourceIndex 
    } = params;

    if (!animeId) {
      throw new Error("Áº∫Â∞ëÂøÖË¶ÅÂèÇÊï∞: animeId");
    }

    const servers = { server1, server2, server3, server4, server5 };
    const config = SOURCES_CONFIG[_sourceIndex || 0];
    const serverUrl = servers[config.key];
    
    if (!serverUrl) {
      throw new Error("ÊúçÂä°Âô®ÈÖçÁΩÆ‰∏çÂ≠òÂú®");
    }
    
    console.log(`‰ªéÊ∫ê${(_sourceIndex || 0) + 1}Ëé∑ÂèñËØ¶ÊÉÖ: ${animeId}`);

    if (config.type === "dandanplay") {
      return await getDetailFromDandanplay(serverUrl, animeId);
    } else {
      return await getDetailFromDirectApi(serverUrl, animeId, _sourceIndex);
    }

  } catch (error) {
    console.error("Ëé∑ÂèñËØ¶ÊÉÖÂ§±Ë¥•:", error);
    throw error;
  }
}

// ÂºπÂºπplayËØ¶ÊÉÖËé∑Âèñ
async function getDetailFromDandanplay(serverUrl, animeId) {
  const response = await Widget.http.get(
    `${serverUrl}/api/v2/bangumi/${animeId}`,
    {
      headers: {
        "Content-Type": "application/json",
        "User-Agent": "ForwardWidgets/1.0.0"
      }
    }
  );

  if (!response || !response.data) {
    throw new Error("Ëé∑ÂèñÂºπÂºπplayËØ¶ÊÉÖÊï∞ÊçÆÂ§±Ë¥•");
  }

  return response.data.bangumi.episodes;
}

// Áõ¥Êé•APIËØ¶ÊÉÖËé∑Âèñ
async function getDetailFromDirectApi(serverUrl, animeId, sourceIndex) {
  try {
    let response;
    
    // Â∞ùËØï‰∏çÂêåÁöÑËØ∑Ê±ÇÊñπÂºè
    try {
      // Â∞ùËØïÊñπÂºè1: Êü•ËØ¢ÂèÇÊï∞
      response = await Widget.http.get(`${serverUrl}?id=${animeId}&action=detail`, {
        headers: {
          "Content-Type": "application/json",
          "User-Agent": "ForwardWidgets/1.0.0"
        }
      });
    } catch (e1) {
      try {
        // Â∞ùËØïÊñπÂºè2: POSTËØ∑Ê±Ç
        response = await Widget.http.post(serverUrl, {
          id: animeId,
          action: "detail"
        }, {
          headers: {
            "Content-Type": "application/json",
            "User-Agent": "ForwardWidgets/1.0.0"
          }
        });
      } catch (e2) {
        // Â∞ùËØïÊñπÂºè3: Ë∑ØÂæÑÂèÇÊï∞
        response = await Widget.http.get(`${serverUrl}/${animeId}`, {
          headers: {
            "Content-Type": "application/json",
            "User-Agent": "ForwardWidgets/1.0.0"
          }
        });
      }
    }

    if (!response || !response.data) {
      throw new Error(`Ëé∑ÂèñÊ∫ê${sourceIndex + 1}ËØ¶ÊÉÖÊï∞ÊçÆÂ§±Ë¥•`);
    }

    return convertDirectApiEpisodeFormat(response.data, sourceIndex);
  } catch (error) {
    console.error(`Ê∫ê${sourceIndex + 1}ËØ¶ÊÉÖËé∑ÂèñÂ§±Ë¥•:`, error);
    throw error;
  }
}

// ËΩ¨Êç¢Áõ¥Êé•APIÁöÑÂâßÈõÜÊï∞ÊçÆÊ†ºÂºè
function convertDirectApiEpisodeFormat(data, sourceIndex) {
  try {
    let episodes = [];
    
    if (data.episodes) {
      episodes = data.episodes;
    } else if (data.episode_list) {
      episodes = data.episode_list.map(ep => ({
        episodeId: ep.episode_id || ep.id,
        episodeTitle: ep.episode_title || ep.title,
        episodeNumber: ep.episode_num || ep.number
      }));
    } else if (data.data && Array.isArray(data.data)) {
      episodes = data.data.map(ep => ({
        episodeId: ep.id || ep.ep_id,
        episodeTitle: ep.title || ep.ep_title,
        episodeNumber: ep.number || ep.ep_index || ep.sort
      }));
    } else if (data.list) {
      episodes = data.list.map(ep => ({
        episodeId: ep.id || ep.cid,
        episodeTitle: ep.title || ep.name,
        episodeNumber: ep.number || ep.sort
      }));
    } else if (Array.isArray(data)) {
      episodes = data.map(ep => ({
        episodeId: ep.id || ep.episodeId,
        episodeTitle: ep.title || ep.episodeTitle,
        episodeNumber: ep.number || ep.episodeNumber
      }));
    }
    
    return episodes;
  } catch (error) {
    console.error(`Ê∫ê${sourceIndex + 1}ÂâßÈõÜÊï∞ÊçÆËΩ¨Êç¢Â§±Ë¥•:`, error);
    return [];
  }
}

async function getCommentsById(params = {}) {
  try {
    const { 
      server1, server2, server3, server4, server5,
      commentId, enabledSources, mergeMode, _sourceIndex 
    } = params;

    if (!commentId) {
      console.log("Ê≤°ÊúâÊèê‰æõcommentIdÔºåÊó†Ê≥ïËé∑ÂèñÂºπÂπï");
      return null;
    }

    const servers = { server1, server2, server3, server4, server5 };
    
    console.log(`Ëé∑ÂèñÂºπÂπï: ${commentId}, Êù•Ê∫ê: ${_sourceIndex !== undefined ? _sourceIndex + 1 : 'Êú™ÊåáÂÆö'}`);

    // Â¶ÇÊûúÊåáÂÆö‰∫ÜÊ∫êÁ¥¢ÂºïÔºåÂè™‰ªéËØ•Ê∫êËé∑Âèñ
    if (_sourceIndex !== undefined) {
      const config = SOURCES_CONFIG[_sourceIndex];
      const serverUrl = servers[config.key];
      
      if (serverUrl) {
        if (config.type === "dandanplay") {
          return await getCommentsFromDandanplay(serverUrl, commentId);
        } else {
          return await getCommentsFromDirectApi(serverUrl, commentId, _sourceIndex);
        }
      }
    }

    // Ê†πÊçÆÂêàÂπ∂Ê®°ÂºèÂ§ÑÁêÜ
    if (mergeMode === "merge") {
      return await getMergedComments(servers, commentId, enabledSources);
    } else {
      return await getCommentsFirstSuccess(servers, commentId, enabledSources);
    }

  } catch (error) {
    console.error("Ëé∑ÂèñÂºπÂπïÂ§±Ë¥•:", error);
    throw error;
  }
}

// ÂêàÂπ∂Â§ö‰∏™Ê∫êÁöÑÂºπÂπï
async function getMergedComments(servers, commentId, enabledSources) {
  const enabledList = getEnabledSourcesList(enabledSources);
  const promises = [];
  let allComments = [];
  
  console.log(`ÂºÄÂßãÂêàÂπ∂ÂºπÂπïÔºåÂêØÁî®Ê∫ê: ${enabledList.length}‰∏™`);

  enabledList.forEach(sourceIndex => {
    const config = SOURCES_CONFIG[sourceIndex];
    const serverUrl = servers[config.key];
    
    if (serverUrl) {
      if (config.type === "dandanplay") {
        promises.push(getCommentsFromDandanplay(serverUrl, commentId));
      } else {
        promises.push(getCommentsFromDirectApi(serverUrl, commentId, sourceIndex));
      }
    }
  });
  
  if (promises.length === 0) {
    return null;
  }

  const results = await Promise.allSettled(promises);
  
  results.forEach((result, index) => {
    if (result.status === "fulfilled" && result.value && result.value.comments) {
      const sourceIndex = enabledList[index];
      const comments = result.value.comments.map(comment => ({
        ...comment,
        _source: sourceIndex
      }));
      allComments = allComments.concat(comments);
      console.log(`Ê∫ê${sourceIndex + 1}Êèê‰æõ${comments.length}Êù°ÂºπÂπï`);
    }
  });
  
  // ÊåâÊó∂Èó¥ÊéíÂ∫è
  allComments.sort((a, b) => {
    const timeA = parseFloat(a.p.split(',')[0]);
    const timeB = parseFloat(b.p.split(',')[0]);
    return timeA - timeB;
  });
  
  console.log(`ÂºπÂπïÂêàÂπ∂ÂÆåÊàêÔºåÂÖ±${allComments.length}Êù°`);
  
  return {
    count: allComments.length,
    comments: allComments
  };
}

// Ëé∑ÂèñÁ¨¨‰∏Ä‰∏™ÊàêÂäüÁöÑÊ∫êÁöÑÂºπÂπï
async function getCommentsFirstSuccess(servers, commentId, enabledSources) {
  const enabledList = getEnabledSourcesList(enabledSources);
  
  for (const sourceIndex of enabledList) {
    try {
      const config = SOURCES_CONFIG[sourceIndex];
      const serverUrl = servers[config.key];
      
      if (serverUrl) {
        console.log(`Â∞ùËØï‰ªéÊ∫ê${sourceIndex + 1}Ëé∑ÂèñÂºπÂπï`);
        
        let result;
        if (config.type === "dandanplay") {
          result = await getCommentsFromDandanplay(serverUrl, commentId);
        } else {
          result = await getCommentsFromDirectApi(serverUrl, commentId, sourceIndex);
        }
        
        if (result && result.comments && result.comments.length > 0) {
          console.log(`Ê∫ê${sourceIndex + 1}ÊàêÂäüËé∑Âèñ${result.comments.length}Êù°ÂºπÂπï`);
          return result;
        }
      }
    } catch (error) {
      console.error(`Ê∫ê${sourceIndex + 1}ÂºπÂπïËé∑ÂèñÂ§±Ë¥•ÔºåÂ∞ùËØï‰∏ã‰∏Ä‰∏™Ê∫ê:`, error.message);
      continue;
    }
  }
  
  console.log("ÊâÄÊúâÊ∫êÈÉΩËé∑ÂèñÂºπÂπïÂ§±Ë¥•");
  return null;
}

// ÂºπÂºπplayÂºπÂπïËé∑Âèñ
async function getCommentsFromDandanplay(serverUrl, commentId) {
  const response = await Widget.http.get(
    `${serverUrl}/api/v2/comment/${commentId}?withRelated=true&chConvert=1`,
    {
      headers: {
        "Content-Type": "application/json",
        "User-Agent": "ForwardWidgets/1.0.0"
      }
    }
  );
  
  if (!response || !response.data) {
    throw new Error("ÂºπÂºπplayÂºπÂπïÊï∞ÊçÆ‰∏∫Á©∫");
  }
  
  return response.data;
}

// Áõ¥Êé•APIÂºπÂπïËé∑Âèñ
async function getCommentsFromDirectApi(serverUrl, commentId, sourceIndex) {
  try {
    let response;
    
    // Â∞ùËØï‰∏çÂêåÁöÑËØ∑Ê±ÇÊñπÂºèËé∑ÂèñÂºπÂπï
    try {
      // ÊñπÂºè1: Êü•ËØ¢ÂèÇÊï∞
      response = await Widget.http.get(`${serverUrl}?id=${commentId}&action=comments`, {
        headers: {
          "Content-Type": "application/json",
          "User-Agent": "ForwardWidgets/1.0.0"
        }
      });
    } catch (e1) {
      try {
        // ÊñπÂºè2: POSTËØ∑Ê±Ç
        response = await Widget.http.post(serverUrl, {
          id: commentId,
          action: "comments"
        }, {
          headers: {
            "Content-Type": "application/json",
            "User-Agent": "ForwardWidgets/1.0.0"
          }
        });
      } catch (e2) {
        try {
          // ÊñπÂºè3: Ë∑ØÂæÑÂèÇÊï∞
          response = await Widget.http.get(`${serverUrl}/${commentId}`, {
            headers: {
              "Content-Type": "application/json",
              "User-Agent": "ForwardWidgets/1.0.0"
            }
          });
        } catch (e3) {
          // ÊñπÂºè4: Áõ¥Êé•ËØ∑Ê±ÇÔºàÂèØËÉΩAPIÂ∑≤ÂåÖÂê´ÊâÄÊúâ‰ø°ÊÅØÔºâ
          response = await Widget.http.get(serverUrl, {
            headers: {
              "Content-Type": "application/json",
              "User-Agent": "ForwardWidgets/1.0.0"
            }
          });
        }
      }
    }
    
    if (!response || !response.data) {
      throw new Error(`Ê∫ê${sourceIndex + 1}ÂºπÂπïÊï∞ÊçÆ‰∏∫Á©∫`);
    }
    
    return convertDirectApiCommentsFormat(response.data, sourceIndex);
  } catch (error) {
    console.error(`Ê∫ê${sourceIndex + 1}ÂºπÂπïËé∑ÂèñÂ§±Ë¥•:`, error);
    throw error;
  }
}

// ËΩ¨Êç¢Áõ¥Êé•APIÁöÑÂºπÂπïÊï∞ÊçÆÊ†ºÂºè
function convertDirectApiCommentsFormat(data, sourceIndex) {
  try {
    let comments = [];
    
    // Â∞ùËØïËØÜÂà´‰∏çÂêåÁöÑÂºπÂπïÊï∞ÊçÆÊ†ºÂºè
    if (data.comments) {
      // Ê†áÂáÜcommentsÊ†ºÂºè
      comments = data.comments.map(comment => {
        if (typeof comment.p === 'string') {
          return comment; // Â∑≤ÁªèÊòØÊ†áÂáÜÊ†ºÂºè
        }
        return {
          cid: comment.id || comment.cid,
          p: `${comment.time || comment.playTime || 0},${comment.mode || 1},${comment.color || 16777215},${comment.timestamp || comment.createTime || 0}`,
          m: comment.text || comment.message || comment.content
        };
      });
    } else if (data.danmu_list) {
      // danmu_listÊ†ºÂºè
      comments = data.danmu_list.map(comment => ({
        cid: comment.cid || comment.id,
        p: `${comment.playTime || comment.time || 0},${comment.mode || 1},${comment.color || 16777215},${comment.createTime || comment.timestamp || 0}`,
        m: comment.message || comment.text || comment.content
      }));
    } else if (data.data) {
      // dataÊ†ºÂºè
      comments = data.data.map(comment => ({
        cid: comment.comment_id || comment.id,
        p: `${comment.play_time || comment.time || 0},${comment.type || comment.mode || 1},${comment.color || 16777215},${comment.create_time || comment.timestamp || 0}`,
        m: comment.content || comment.text || comment.message
      }));
    } else if (data.list) {
      // listÊ†ºÂºè
      comments = data.list.map(comment => ({
        cid: comment.id || comment.cid,
        p: `${comment.stime || comment.time || 0},${comment.mode || 1},${comment.color || 16777215},${comment.date || comment.timestamp || 0}`,
        m: comment.message || comment.text || comment.content
      }));
    } else if (data.result) {
      // resultÊ†ºÂºè
      comments = data.result.map(comment => ({
        cid: comment.id || comment.cid,
        p: `${comment.time || 0},${comment.mode || 1},${comment.color || 16777215},${comment.date || comment.timestamp || 0}`,
        m: comment.text || comment.message
      }));
    } else if (Array.isArray(data)) {
      // Áõ¥Êé•Êï∞ÁªÑÊ†ºÂºè
      comments = data.map(comment => ({
        cid: comment.id || comment.cid,
        p: `${comment.time || comment.playTime || 0},${comment.mode || 1},${comment.color || 16777215},${comment.timestamp || comment.createTime || 0}`,
        m: comment.text || comment.message || comment.content
      }));
    } else {
      // Â∞ùËØï‰ªéÂÖ∂‰ªñÂèØËÉΩÁöÑÂ≠óÊÆµ‰∏≠ÊèêÂèñÂºπÂπïÊï∞ÊçÆ
      const possibleFields = ['items', 'records', 'rows', 'content'];
      for (const field of possibleFields) {
        if (data[field] && Array.isArray(data[field])) {
          comments = data[field].map(comment => ({
            cid: comment.id || comment.cid || Math.random().toString(36).substr(2, 9),
            p: `${comment.time || comment.playTime || comment.stime || 0},${comment.mode || comment.type || 1},${comment.color || 16777215},${comment.timestamp || comment.createTime || comment.date || 0}`,
            m: comment.text || comment.message || comment.content || comment.msg || ''
          }));
          break;
        }
      }
    }
    
    // ËøáÊª§ÊéâÁ©∫ÁöÑÂºπÂπïÂÜÖÂÆπ
    comments = comments.filter(comment => comment.m && comment.m.trim() !== '');
    
    return {
      count: comments.length,
      comments: comments
    };
  } catch (error) {
    console.error(`Ê∫ê${sourceIndex + 1}ÂºπÂπïÊï∞ÊçÆËΩ¨Êç¢Â§±Ë¥•:`, error);
    return { 
      count: 0, 
      comments: [] 
    };
  }
}
