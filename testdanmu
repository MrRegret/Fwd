
var WidgetMetadata = {
  id: "danmuAPI",
  title: "danmuAPI",
  description: "",
  author: "ğŸ Discount Codeï¼šVEUS",
  site: "https://github.com/InchStudio/ForwardWidgets",
  version: "2.0.0",
  requiredVersion: "0.0.2",
  detailCacheDuration: 60,
  globalParams: [
    {
      name: "server1",
      title: "é»˜è®¤",
      type: "input",
      placeholders: [
        {
          title: "ç¤ºä¾‹",
          value: "",
        },
      ],
    },
    {
      name: "server2",
      title: "ç¬¬äºŒå¼¹å¹•æº",
      type: "input",
      placeholders: [
        {
          title: "ç¤ºä¾‹: http://example.com:7768/api/token123",
          value: "",
        },
      ],
    },
    {
      name: "server3",
      title: "ç¬¬ä¸‰å¼¹å¹•æº",
      type: "input",
      placeholders: [
        {
          title: "ç¤ºä¾‹: http://example.com:8080/api/token456",
          value: "",
        },
      ],
    },
    {
      name: "server4",
      title: "ç¬¬å››å¼¹å¹•æº",
      type: "input",
      placeholders: [
        {
          title: "ç¤ºä¾‹: http://example.com:9090/api/token789",
          value: "",
        },
      ],
    },
    {
      name: "server5",
      title: "ç¬¬äº”å¼¹å¹•æº",
      type: "input",
      placeholders: [
        {
          title: "ç¤ºä¾‹: http://example.com:3000/api/tokenABC",
          value: "",
        },
      ],
    },
    {
      name: "enabledSources",
      title: "å¯ç”¨çš„å¼¹å¹•æº",
      type: "enumeration",
      enumOptions: [
        { title: "å…¨éƒ¨å¯ç”¨", value: "all" },
        { title: "ä»…ä¸»æº", value: "primary" },
        { title: "ä¸»æº+ç¬¬äºŒæº", value: "two" },
        { title: "å‰ä¸‰ä¸ªæº", value: "three" },
        { title: "è‡ªå®šä¹‰(1,3,5)", value: "custom" }
      ],
      value: "all"
    },
    {
      name: "showAllSources",
      title: "æ˜¾ç¤ºæ‰€æœ‰å¯ç”¨æº",
      type: "enumeration",
      enumOptions: [
        { title: "æ˜¾ç¤ºæ‰€æœ‰å¯ç”¨çš„å¼¹å¹•æº", value: "show_all" },
        { title: "ä»…è¿”å›ç¬¬ä¸€ä¸ªæˆåŠŸçš„æº", value: "first_only" }
      ],
      value: "show_all"
    }
  ],
  modules: [
    {
      id: "searchDanmu",
      title: "æœç´¢å¼¹å¹•",
      functionName: "searchDanmu",
      type: "danmu",
      cacheDuration: 3600,
      params: []
    },
    {
      id: "getDetail",
      title: "è·å–è¯¦æƒ…",
      functionName: "getDetailById",
      type: "danmu",
      cacheDuration: 3600,
      params: []
    },
    {
      id: "getComments",
      title: "è·å–å¼¹å¹•",
      functionName: "getCommentsById",
      type: "danmu",
      cacheDuration: 300,
      params: []
    }
  ]
};

// å¼¹å¹•æºé…ç½®
const SOURCES_CONFIG = [
  { name: "å¼¹å¼¹play", key: "server1", type: "dandanplay" },
  { name: "ç¬¬äºŒæº", key: "server2", type: "direct_api" },
  { name: "ç¬¬ä¸‰æº", key: "server3", type: "direct_api" },
  { name: "ç¬¬å››æº", key: "server4", type: "direct_api" },
  { name: "ç¬¬äº”æº", key: "server5", type: "direct_api" }
];

async function searchDanmu(params = {}) {
  try {
    const { 
      tmdbId, type, title, season, 
      server1, server2, server3, server4, server5,
      enabledSources, showAllSources 
    } = params;

    // å‚æ•°éªŒè¯
    if (!title) {
      throw new Error("ç¼ºå°‘å¿…è¦å‚æ•°: title");
    }

    console.log(`å¼€å§‹æœç´¢å¼¹å¹•: ${title}`);

    const servers = { server1, server2, server3, server4, server5 };
    const enabledList = getEnabledSourcesList(enabledSources || "all");
    const allResults = [];

    // éå†æ‰€æœ‰å¯ç”¨çš„æº
    for (const sourceIndex of enabledList) {
      const config = SOURCES_CONFIG[sourceIndex];
      const serverUrl = servers[config.key];
      
      if (!serverUrl) {
        console.log(`æº${sourceIndex + 1}(${config.name})æœªé…ç½®ï¼Œè·³è¿‡`);
        continue;
      }

      try {
        console.log(`å°è¯•ä»æº${sourceIndex + 1}(${config.name})æœç´¢å¼¹å¹•`);
        
        let result;
        if (config.type === "dandanplay") {
          result = await searchFromDandanplay(serverUrl, params, sourceIndex);
        } else {
          result = await searchFromDirectApi(serverUrl, params, sourceIndex);
        }

        if (result && result.animes && result.animes.length > 0) {
          // ä¸ºç»“æœæ·»åŠ æºä¿¡æ¯
          const animesWithSource = result.animes.map(anime => ({
            ...anime,
            _sourceIndex: sourceIndex,
            _sourceName: config.name,
            _sourceType: config.type
          }));
          
          console.log(`æº${sourceIndex + 1}(${config.name})æˆåŠŸè¿”å›${animesWithSource.length}ä¸ªç»“æœ`);
          
          // æ ¹æ®è®¾ç½®å†³å®šæ˜¯å¦ç»§ç»­æœç´¢å…¶ä»–æº
          if (showAllSources === "show_all") {
            allResults.push(...animesWithSource);
          } else {
            // å¦‚æœè®¾ç½®ä¸ºä»…è¿”å›ç¬¬ä¸€ä¸ªæˆåŠŸçš„æºï¼Œç›´æ¥è¿”å›
            return { animes: animesWithSource };
          }
        } else {
          console.log(`æº${sourceIndex + 1}(${config.name})æœªæ‰¾åˆ°ç»“æœ`);
        }
        
      } catch (error) {
        console.error(`æº${sourceIndex + 1}(${config.name})æœç´¢å¤±è´¥:`, error.message);
        // ç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªæº
        continue;
      }
    }

    if (allResults.length === 0) {
      console.log("æ‰€æœ‰å¼¹å¹•æºéƒ½æœªæ‰¾åˆ°ç»“æœ");
      return { animes: [] };
    }

    // æŒ‰æºç´¢å¼•æ’åºï¼Œä¿æŒä¼˜å…ˆçº§é¡ºåº
    allResults.sort((a, b) => a._sourceIndex - b._sourceIndex);
    
    console.log(`æœç´¢å®Œæˆï¼Œå…±ä»${enabledList.length}ä¸ªæºè¿”å›${allResults.length}ä¸ªç»“æœ`);
    return { animes: allResults };

  } catch (error) {
    console.error("æœç´¢å¼¹å¹•å¤±è´¥:", error);
    throw error;
  }
}

// è·å–å¯ç”¨çš„æºåˆ—è¡¨
function getEnabledSourcesList(enabledSources) {
  switch (enabledSources) {
    case "all":
      return [0, 1, 2, 3, 4];
    case "primary":
      return [0];
    case "two":
      return [0, 1];
    case "three":
      return [0, 1, 2];
    case "custom":
      return [0, 2, 4]; // 1,3,5æº
    default:
      return [0];
  }
}

// å¼¹å¼¹playæœç´¢
async function searchFromDandanplay(serverUrl, params, sourceIndex) {
  try {
    const { type, title, season } = params;
    
    console.log(`æº${sourceIndex + 1}(å¼¹å¼¹play)å¼€å§‹æœç´¢: ${title}`);

    const response = await Widget.http.get(
      `${serverUrl}/api/v2/search/anime?keyword=${encodeURIComponent(title)}`,
      {
        headers: {
          "Content-Type": "application/json",
          "User-Agent": "ForwardWidgets/1.0.0"
        }
      }
    );

    if (!response || !response.data) {
      throw new Error("å¼¹å¼¹playå“åº”æ•°æ®ä¸ºç©º");
    }

    const data = response.data;
    if (!data.success) {
      throw new Error(data.errorMessage || "å¼¹å¼¹play APIè°ƒç”¨å¤±è´¥");
    }

    let animes = [];
    if (data.animes && data.animes.length > 0) {
      animes = data.animes.filter(anime => {
        if ((anime.type === "tvseries" || anime.type === "web") && type === "tv") {
          return true;
        } else if (anime.type === "movie" && type === "movie") {
          return true;
        }
        return false;
      });
      
      // å­£æ•°åŒ¹é…å¤„ç†
      if (season && animes.length > 0) {
        const matchedAnimes = animes.filter(anime => {
          if (anime.animeTitle.includes(title)) {
            const titleParts = anime.animeTitle.split(" ");
            if (titleParts.length > 1) {
              const seasonPart = titleParts[1];
              const seasonIndex = seasonPart.match(/\d+/);
              if (seasonIndex && seasonIndex[0] === season) {
                return true;
              }
              const chineseNumber = seasonPart.match(/[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åå£¹è´°åè‚†ä¼é™†æŸ’æŒç–æ‹¾]+/);
              if (chineseNumber && convertChineseNumber(chineseNumber[0]) === season) {
                return true;
              }
            }
          }
          return false;
        });
        
        if (matchedAnimes.length > 0) {
          animes = matchedAnimes;
        }
      }
    }
    
    console.log(`å¼¹å¼¹playæœç´¢å®Œæˆï¼Œæ‰¾åˆ°${animes.length}ä¸ªç»“æœ`);
    return { animes: animes };

  } catch (error) {
    console.error("å¼¹å¼¹playæœç´¢å¤±è´¥:", error);
    throw error;
  }
}

// ç›´æ¥APIæœç´¢ï¼ˆé€‚é…ç±»ä¼¼ http://host:port/api/token æ ¼å¼ï¼‰
async function searchFromDirectApi(serverUrl, params, sourceIndex) {
  try {
    const { type, title } = params;
    
    console.log(`æº${sourceIndex + 1}å¼€å§‹æœç´¢: ${title}`);

    // ç›´æ¥ä½¿ç”¨æä¾›çš„å®Œæ•´APIåœ°å€ï¼Œå¯èƒ½å·²åŒ…å«token
    let response;
    
    // å°è¯•æ–¹å¼1: ä½œä¸ºæŸ¥è¯¢å‚æ•°
    try {
      response = await Widget.http.get(`${serverUrl}?keyword=${encodeURIComponent(title)}&type=${type}`, {
        headers: {
          "Content-Type": "application/json",
          "User-Agent": "ForwardWidgets/1.0.0"
        }
      });
    } catch (e1) {
      // å°è¯•æ–¹å¼2: POSTè¯·æ±‚
      try {
        response = await Widget.http.post(serverUrl, {
          keyword: title,
          type: type
        }, {
          headers: {
            "Content-Type": "application/json",
            "User-Agent": "ForwardWidgets/1.0.0"
          }
        });
      } catch (e2) {
        // å°è¯•æ–¹å¼3: ç›´æ¥GETï¼ˆå¯èƒ½APIè‡ªèº«åŒ…å«æ‰€éœ€å‚æ•°ï¼‰
        response = await Widget.http.get(serverUrl, {
          headers: {
            "Content-Type": "application/json",
            "User-Agent": "ForwardWidgets/1.0.0"
          }
        });
      }
    }

    if (!response || !response.data) {
      throw new Error(`æº${sourceIndex + 1}å“åº”æ•°æ®ä¸ºç©º`);
    }

    // è½¬æ¢ä¸åŒæºçš„è¿”å›æ ¼å¼ä¸ºæ ‡å‡†æ ¼å¼
    const animes = convertDirectApiResponse(response.data, sourceIndex);
    
    console.log(`æº${sourceIndex + 1}æœç´¢å®Œæˆï¼Œæ‰¾åˆ°${animes.length}ä¸ªç»“æœ`);
    return { animes: animes };

  } catch (error) {
    console.error(`æº${sourceIndex + 1}æœç´¢å¤±è´¥:`, error);
    throw error;
  }
}

// è½¬æ¢ç›´æ¥APIçš„è¿”å›æ ¼å¼ä¸ºæ ‡å‡†æ ¼å¼
function convertDirectApiResponse(data, sourceIndex) {
  try {
    let animes = [];
    
    // å°è¯•è¯†åˆ«å¸¸è§çš„å“åº”æ ¼å¼
    if (data.animes) {
      // ç±»ä¼¼å¼¹å¼¹playæ ¼å¼
      animes = data.animes;
    } else if (data.results) {
      // resultsæ ¼å¼
      animes = data.results.map(item => ({
        animeId: item.id || item.animeId || item.bangumi_id,
        animeTitle: item.title || item.name || item.animeTitle,
        type: item.type || "tvseries",
        episodeCount: item.episode_count || item.episodes || item.episodeCount || 0
      }));
    } else if (data.data) {
      // dataæ ¼å¼
      animes = data.data.map(item => ({
        animeId: item.id || item.anime_id || item.bangumi_id,
        animeTitle: item.title || item.name || item.anime_title,
        type: item.type || item.category || "tvseries",
        episodeCount: item.episode_count || item.episodes || 0
      }));
    } else if (data.list) {
      // listæ ¼å¼
      animes = data.list.map(item => ({
        animeId: item.id || item.bangumi_id,
        animeTitle: item.title || item.name || item.bangumi_name,
        type: item.type || item.kind || "tvseries",
        episodeCount: item.episode_count || item.ep_count || 0
      }));
    } else if (Array.isArray(data)) {
      // ç›´æ¥æ•°ç»„æ ¼å¼
      animes = data.map(item => ({
        animeId: item.id || item.animeId,
        animeTitle: item.title || item.name || item.animeTitle,
        type: item.type || "tvseries",
        episodeCount: item.episode_count || item.episodes || 0
      }));
    }
    
    return animes;
  } catch (error) {
    console.error(`æº${sourceIndex + 1}æ•°æ®è½¬æ¢å¤±è´¥:`, error);
    return [];
  }
}

// å»é‡å¤„ç†
function removeDuplicateResults(animes) {
  const seen = new Map();
  return animes.filter(anime => {
    const key = `${anime.animeTitle?.toLowerCase()?.trim()}-${anime.type}`;
    if (seen.has(key)) {
      const existing = seen.get(key);
      if (anime._sourceIndex < existing._sourceIndex) {
        seen.set(key, anime);
        return true;
      }
      return false;
    }
    seen.set(key, anime);
    return true;
  });
}

// å»é‡å¤„ç†ï¼ˆç°åœ¨æ”¹ä¸ºæŒ‰æºåˆ†ç»„å±•ç¤ºæ‰€æœ‰ç»“æœï¼‰
function removeDuplicateResults(animes) {
  // ä¸å†å»é‡ï¼Œè€Œæ˜¯æŒ‰æºç´¢å¼•æ’åºï¼Œä¿ç•™æ‰€æœ‰ç»“æœ
  return animes.sort((a, b) => a._sourceIndex - b._sourceIndex);
}

// ä¸­æ–‡æ•°å­—è½¬æ¢
function convertChineseNumber(chineseNumber) {
  if (/^\d+$/.test(chineseNumber)) {
    return Number(chineseNumber);
  }
  
  const digits = {
    'é›¶': 0, 'ä¸€': 1, 'äºŒ': 2, 'ä¸‰': 3, 'å››': 4, 'äº”': 5,
    'å…­': 6, 'ä¸ƒ': 7, 'å…«': 8, 'ä¹': 9,
    'å£¹': 1, 'è²³': 2, 'åƒ': 3, 'è‚†': 4, 'ä¼': 5,
    'é™¸': 6, 'æŸ’': 7, 'æŒ': 8, 'ç–': 9
  };
  
  const units = {
    'å': 10, 'ç™¾': 100, 'åƒ': 1000,
    'æ‹¾': 10, 'ä½°': 100, 'ä»Ÿ': 1000
  };
  
  let result = 0;
  let current = 0;
  let lastUnit = 1;
  
  for (let i = 0; i < chineseNumber.length; i++) {
    const char = chineseNumber[i];
    
    if (digits[char] !== undefined) {
      current = digits[char];
    } else if (units[char] !== undefined) {
      const unit = units[char];
      
      if (current === 0) current = 1;
      
      if (unit >= lastUnit) {
        result = current * unit;
      } else {
        result += current * unit;
      }
      
      lastUnit = unit;
      current = 0;
    }
  }
  
  if (current > 0) {
    result += current;
  }
  
  return result;
}

async function getDetailById(params = {}) {
  try {
    const { 
      server1, server2, server3, server4, server5,
      animeId, _sourceIndex 
    } = params;

    if (!animeId) {
      throw new Error("ç¼ºå°‘å¿…è¦å‚æ•°: animeId");
    }

    const servers = { server1, server2, server3, server4, server5 };
    const config = SOURCES_CONFIG[_sourceIndex || 0];
    const serverUrl = servers[config.key];
    
    if (!serverUrl) {
      throw new Error("æœåŠ¡å™¨é…ç½®ä¸å­˜åœ¨");
    }
    
    console.log(`ä»æº${(_sourceIndex || 0) + 1}è·å–è¯¦æƒ…: ${animeId}`);

    if (config.type === "dandanplay") {
      return await getDetailFromDandanplay(serverUrl, animeId);
    } else {
      return await getDetailFromDirectApi(serverUrl, animeId, _sourceIndex);
    }

  } catch (error) {
    console.error("è·å–è¯¦æƒ…å¤±è´¥:", error);
    throw error;
  }
}

// å¼¹å¼¹playè¯¦æƒ…è·å–
async function getDetailFromDandanplay(serverUrl, animeId) {
  const response = await Widget.http.get(
    `${serverUrl}/api/v2/bangumi/${animeId}`,
    {
      headers: {
        "Content-Type": "application/json",
        "User-Agent": "ForwardWidgets/1.0.0"
      }
    }
  );

  if (!response || !response.data) {
    throw new Error("è·å–å¼¹å¼¹playè¯¦æƒ…æ•°æ®å¤±è´¥");
  }

  return response.data.bangumi.episodes;
}

// ç›´æ¥APIè¯¦æƒ…è·å–
async function getDetailFromDirectApi(serverUrl, animeId, sourceIndex) {
  try {
    let response;
    
    // å°è¯•ä¸åŒçš„è¯·æ±‚æ–¹å¼
    try {
      // å°è¯•æ–¹å¼1: æŸ¥è¯¢å‚æ•°
      response = await Widget.http.get(`${serverUrl}?id=${animeId}&action=detail`, {
        headers: {
          "Content-Type": "application/json",
          "User-Agent": "ForwardWidgets/1.0.0"
        }
      });
    } catch (e1) {
      try {
        // å°è¯•æ–¹å¼2: POSTè¯·æ±‚
        response = await Widget.http.post(serverUrl, {
          id: animeId,
          action: "detail"
        }, {
          headers: {
            "Content-Type": "application/json",
            "User-Agent": "ForwardWidgets/1.0.0"
          }
        });
      } catch (e2) {
        // å°è¯•æ–¹å¼3: è·¯å¾„å‚æ•°
        response = await Widget.http.get(`${serverUrl}/${animeId}`, {
          headers: {
            "Content-Type": "application/json",
            "User-Agent": "ForwardWidgets/1.0.0"
          }
        });
      }
    }

    if (!response || !response.data) {
      throw new Error(`è·å–æº${sourceIndex + 1}è¯¦æƒ…æ•°æ®å¤±è´¥`);
    }

    return convertDirectApiEpisodeFormat(response.data, sourceIndex);
  } catch (error) {
    console.error(`æº${sourceIndex + 1}è¯¦æƒ…è·å–å¤±è´¥:`, error);
    throw error;
  }
}

// è½¬æ¢ç›´æ¥APIçš„å‰§é›†æ•°æ®æ ¼å¼
function convertDirectApiEpisodeFormat(data, sourceIndex) {
  try {
    let episodes = [];
    
    if (data.episodes) {
      episodes = data.episodes;
    } else if (data.episode_list) {
      episodes = data.episode_list.map(ep => ({
        episodeId: ep.episode_id || ep.id,
        episodeTitle: ep.episode_title || ep.title,
        episodeNumber: ep.episode_num || ep.number
      }));
    } else if (data.data && Array.isArray(data.data)) {
      episodes = data.data.map(ep => ({
        episodeId: ep.id || ep.ep_id,
        episodeTitle: ep.title || ep.ep_title,
        episodeNumber: ep.number || ep.ep_index || ep.sort
      }));
    } else if (data.list) {
      episodes = data.list.map(ep => ({
        episodeId: ep.id || ep.cid,
        episodeTitle: ep.title || ep.name,
        episodeNumber: ep.number || ep.sort
      }));
    } else if (Array.isArray(data)) {
      episodes = data.map(ep => ({
        episodeId: ep.id || ep.episodeId,
        episodeTitle: ep.title || ep.episodeTitle,
        episodeNumber: ep.number || ep.episodeNumber
      }));
    }
    
    return episodes;
  } catch (error) {
    console.error(`æº${sourceIndex + 1}å‰§é›†æ•°æ®è½¬æ¢å¤±è´¥:`, error);
    return [];
  }
}

async function getCommentsById(params = {}) {
  try {
    const { 
      server1, server2, server3, server4, server5,
      commentId, enabledSources, showAllSources, _sourceIndex 
    } = params;

    if (!commentId) {
      console.log("æ²¡æœ‰æä¾›commentIdï¼Œæ— æ³•è·å–å¼¹å¹•");
      return null;
    }

    const servers = { server1, server2, server3, server4, server5 };
    
    console.log(`è·å–å¼¹å¹•: ${commentId}, æ¥æº: ${_sourceIndex !== undefined ? _sourceIndex + 1 : 'æœªæŒ‡å®š'}`);

    // å¦‚æœæŒ‡å®šäº†æºç´¢å¼•ï¼Œåªä»è¯¥æºè·å–
    if (_sourceIndex !== undefined) {
      const config = SOURCES_CONFIG[_sourceIndex];
      const serverUrl = servers[config.key];
      
      if (serverUrl) {
        if (config.type === "dandanplay") {
          return await getCommentsFromDandanplay(serverUrl, commentId);
        } else {
          return await getCommentsFromDirectApi(serverUrl, commentId, _sourceIndex);
        }
      }
    }

    // æŒ‰ä¼˜å…ˆçº§é¡ºåºå°è¯•å„ä¸ªæºï¼ˆå¼¹å¹•è·å–é€šå¸¸ä½¿ç”¨ç¬¬ä¸€ä¸ªæˆåŠŸçš„æºï¼‰
    return await getCommentsFirstSuccess(servers, commentId, enabledSources);

  } catch (error) {
    console.error("è·å–å¼¹å¹•å¤±è´¥:", error);
    throw error;
  }
}

// è·å–ç¬¬ä¸€ä¸ªæˆåŠŸçš„æºçš„å¼¹å¹•
async function getCommentsFirstSuccess(servers, commentId, enabledSources) {
  const enabledList = getEnabledSourcesList(enabledSources);
  
  for (const sourceIndex of enabledList) {
    try {
      const config = SOURCES_CONFIG[sourceIndex];
      const serverUrl = servers[config.key];
      
      if (!serverUrl) {
        console.log(`æº${sourceIndex + 1}(${config.name})æœªé…ç½®ï¼Œè·³è¿‡`);
        continue;
      }

      console.log(`å°è¯•ä»æº${sourceIndex + 1}(${config.name})è·å–å¼¹å¹•`);
      
      let result;
      if (config.type === "dandanplay") {
        result = await getCommentsFromDandanplay(serverUrl, commentId);
      } else {
        result = await getCommentsFromDirectApi(serverUrl, commentId, sourceIndex);
      }
      
      if (result && result.comments && result.comments.length > 0) {
        console.log(`æº${sourceIndex + 1}(${config.name})æˆåŠŸè·å–${result.comments.length}æ¡å¼¹å¹•`);
        return result;
      } else {
        console.log(`æº${sourceIndex + 1}(${config.name})æœªæ‰¾åˆ°å¼¹å¹•æ•°æ®`);
      }
    } catch (error) {
      console.error(`æº${sourceIndex + 1}å¼¹å¹•è·å–å¤±è´¥ï¼Œå°è¯•ä¸‹ä¸€ä¸ªæº:`, error.message);
      continue;
    }
  }
  
  console.log("æ‰€æœ‰æºéƒ½è·å–å¼¹å¹•å¤±è´¥");
  return null;
}

// å¼¹å¼¹playå¼¹å¹•è·å–
async function getCommentsFromDandanplay(serverUrl, commentId) {
  const response = await Widget.http.get(
    `${serverUrl}/api/v2/comment/${commentId}?withRelated=true&chConvert=1`,
    {
      headers: {
        "Content-Type": "application/json",
        "User-Agent": "ForwardWidgets/1.0.0"
      }
    }
  );
  
  if (!response || !response.data) {
    throw new Error("å¼¹å¼¹playå¼¹å¹•æ•°æ®ä¸ºç©º");
  }
  
  return response.data;
}

// ç›´æ¥APIå¼¹å¹•è·å–
async function getCommentsFromDirectApi(serverUrl, commentId, sourceIndex) {
  try {
    let response;
    
    // å°è¯•ä¸åŒçš„è¯·æ±‚æ–¹å¼è·å–å¼¹å¹•
    try {
      // æ–¹å¼1: æŸ¥è¯¢å‚æ•°
      response = await Widget.http.get(`${serverUrl}?id=${commentId}&action=comments`, {
        headers: {
          "Content-Type": "application/json",
          "User-Agent": "ForwardWidgets/1.0.0"
        }
      });
    } catch (e1) {
      try {
        // æ–¹å¼2: POSTè¯·æ±‚
        response = await Widget.http.post(serverUrl, {
          id: commentId,
          action: "comments"
        }, {
          headers: {
            "Content-Type": "application/json",
            "User-Agent": "ForwardWidgets/1.0.0"
          }
        });
      } catch (e2) {
        try {
          // æ–¹å¼3: è·¯å¾„å‚æ•°
          response = await Widget.http.get(`${serverUrl}/${commentId}`, {
            headers: {
              "Content-Type": "application/json",
              "User-Agent": "ForwardWidgets/1.0.0"
            }
          });
        } catch (e3) {
          // æ–¹å¼4: ç›´æ¥è¯·æ±‚ï¼ˆå¯èƒ½APIå·²åŒ…å«æ‰€æœ‰ä¿¡æ¯ï¼‰
          response = await Widget.http.get(serverUrl, {
            headers: {
              "Content-Type": "application/json",
              "User-Agent": "ForwardWidgets/1.0.0"
            }
          });
        }
      }
    }
    
    if (!response || !response.data) {
      throw new Error(`æº${sourceIndex + 1}å¼¹å¹•æ•°æ®ä¸ºç©º`);
    }
    
    return convertDirectApiCommentsFormat(response.data, sourceIndex);
  } catch (error) {
    console.error(`æº${sourceIndex + 1}å¼¹å¹•è·å–å¤±è´¥:`, error);
    throw error;
  }
}

// è½¬æ¢ç›´æ¥APIçš„å¼¹å¹•æ•°æ®æ ¼å¼
function convertDirectApiCommentsFormat(data, sourceIndex) {
  try {
    let comments = [];
    
    // å°è¯•è¯†åˆ«ä¸åŒçš„å¼¹å¹•æ•°æ®æ ¼å¼
    if (data.comments) {
      // æ ‡å‡†commentsæ ¼å¼
      comments = data.comments.map(comment => {
        if (typeof comment.p === 'string') {
          return comment; // å·²ç»æ˜¯æ ‡å‡†æ ¼å¼
        }
        return {
          cid: comment.id || comment.cid,
          p: `${comment.time || comment.playTime || 0},${comment.mode || 1},${comment.color || 16777215},${comment.timestamp || comment.createTime || 0}`,
          m: comment.text || comment.message || comment.content
        };
      });
    } else if (data.danmu_list) {
      // danmu_listæ ¼å¼
      comments = data.danmu_list.map(comment => ({
        cid: comment.cid || comment.id,
        p: `${comment.playTime || comment.time || 0},${comment.mode || 1},${comment.color || 16777215},${comment.createTime || comment.timestamp || 0}`,
        m: comment.message || comment.text || comment.content
      }));
    } else if (data.data) {
      // dataæ ¼å¼
      comments = data.data.map(comment => ({
        cid: comment.comment_id || comment.id,
        p: `${comment.play_time || comment.time || 0},${comment.type || comment.mode || 1},${comment.color || 16777215},${comment.create_time || comment.timestamp || 0}`,
        m: comment.content || comment.text || comment.message
      }));
    } else if (data.list) {
      // listæ ¼å¼
      comments = data.list.map(comment => ({
        cid: comment.id || comment.cid,
        p: `${comment.stime || comment.time || 0},${comment.mode || 1},${comment.color || 16777215},${comment.date || comment.timestamp || 0}`,
        m: comment.message || comment.text || comment.content
      }));
    } else if (data.result) {
      // resultæ ¼å¼
      comments = data.result.map(comment => ({
        cid: comment.id || comment.cid,
        p: `${comment.time || 0},${comment.mode || 1},${comment.color || 16777215},${comment.date || comment.timestamp || 0}`,
        m: comment.text || comment.message
      }));
    } else if (Array.isArray(data)) {
      // ç›´æ¥æ•°ç»„æ ¼å¼
      comments = data.map(comment => ({
        cid: comment.id || comment.cid,
        p: `${comment.time || comment.playTime || 0},${comment.mode || 1},${comment.color || 16777215},${comment.timestamp || comment.createTime || 0}`,
        m: comment.text || comment.message || comment.content
      }));
    } else {
      // å°è¯•ä»å…¶ä»–å¯èƒ½çš„å­—æ®µä¸­æå–å¼¹å¹•æ•°æ®
      const possibleFields = ['items', 'records', 'rows', 'content'];
      for (const field of possibleFields) {
        if (data[field] && Array.isArray(data[field])) {
          comments = data[field].map(comment => ({
            cid: comment.id || comment.cid || Math.random().toString(36).substr(2, 9),
            p: `${comment.time || comment.playTime || comment.stime || 0},${comment.mode || comment.type || 1},${comment.color || 16777215},${comment.timestamp || comment.createTime || comment.date || 0}`,
            m: comment.text || comment.message || comment.content || comment.msg || ''
          }));
          break;
        }
      }
    }
    
    // è¿‡æ»¤æ‰ç©ºçš„å¼¹å¹•å†…å®¹
    comments = comments.filter(comment => comment.m && comment.m.trim() !== '');
    
    return {
      count: comments.length,
      comments: comments
    };
  } catch (error) {
    console.error(`æº${sourceIndex + 1}å¼¹å¹•æ•°æ®è½¬æ¢å¤±è´¥:`, error);
    return { 
      count: 0, 
      comments: [] 
    };
  }
}
